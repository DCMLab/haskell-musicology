-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Networked stream transducers
--   
--   Networked stream transducers
--   
--   RÃºnar Bjarnason's talk on machines can be downloaded from:
--   <a>http://web.archive.org/web/20161029161813/https://dl.dropboxusercontent.com/u/4588997/Machines.pdf</a>
@package machines
@version 0.7.3


module Data.Machine.Is

-- | Witnessed type equality
data Is a b
[Refl] :: Is a a
instance GHC.Show.Show (Data.Machine.Is.Is a b)
instance GHC.Classes.Eq (Data.Machine.Is.Is a b)
instance GHC.Classes.Ord (Data.Machine.Is.Is a b)
instance (a GHC.Types.~ b) => GHC.Base.Semigroup (Data.Machine.Is.Is a b)
instance (a GHC.Types.~ b) => GHC.Base.Monoid (Data.Machine.Is.Is a b)
instance (a GHC.Types.~ b) => GHC.Read.Read (Data.Machine.Is.Is a b)
instance Control.Category.Category Data.Machine.Is.Is


module Data.Machine.Plan

-- | A <tt><a>Plan</a> k o a</tt> is a specification for a pure
--   <tt>Machine</tt>, that reads inputs selected by <tt>k</tt> with types
--   based on <tt>i</tt>, writes values of type <tt>o</tt>, and has
--   intermediate results of type <tt>a</tt>.
--   
--   A <tt><a>Plan</a> k o a</tt> can be used as a <tt><a>PlanT</a> k o m
--   a</tt> for any <tt><a>Monad</a> m</tt>.
--   
--   It is perhaps easier to think of <a>Plan</a> in its un-cps'ed form,
--   which would look like:
--   
--   <pre>
--   data <a>Plan</a> k o a
--     = Done a
--     | Yield o (Plan k o a)
--     | forall z. Await (z -&gt; Plan k o a) (k z) (Plan k o a)
--     | Fail
--   </pre>
type Plan k o a = forall m. PlanT k o m a

-- | Deconstruct a <a>Plan</a> without reference to a <a>Monad</a>.
runPlan :: PlanT k o Identity a -> (a -> r) -> (o -> r -> r) -> (forall z. (z -> r) -> k z -> r -> r) -> r -> r

-- | You can <tt>construct</tt> a <a>Plan</a> (or <a>PlanT</a>), turning it
--   into a <a>Machine</a> (or <a>MachineT</a>).
newtype PlanT k o m a
PlanT :: (forall r. (a -> m r) -> (o -> m r -> m r) -> (forall z. (z -> m r) -> k z -> m r -> m r) -> m r -> m r) -> PlanT k o m a
[runPlanT] :: PlanT k o m a -> forall r. (a -> m r) -> (o -> m r -> m r) -> (forall z. (z -> m r) -> k z -> m r -> m r) -> m r -> m r

-- | Output a result.
yield :: o -> Plan k o ()

-- | Like yield, except stops if there is no value to yield.
maybeYield :: Maybe o -> Plan k o ()

-- | Wait for input.
--   
--   <pre>
--   <a>await</a> = <a>awaits</a> <a>id</a>
--   </pre>
await :: Category k => Plan (k i) o i

-- | <pre>
--   <a>stop</a> = <a>empty</a>
--   </pre>
stop :: Plan k o a

-- | Wait for a particular input.
--   
--   <pre>
--   awaits <tt>L</tt>  :: <a>Plan</a> (<tt>T</tt> a b) o a
--   awaits <tt>R</tt>  :: <a>Plan</a> (<tt>T</tt> a b) o b
--   awaits <a>id</a> :: <a>Plan</a> (<a>Is</a> i) o i
--   </pre>
awaits :: k i -> Plan k o i

-- | Run a monadic action repeatedly yielding its results, until it returns
--   Nothing.
exhaust :: Monad m => m (Maybe a) -> PlanT k a m ()
instance GHC.Base.Functor (Data.Machine.Plan.PlanT k o m)
instance GHC.Base.Applicative (Data.Machine.Plan.PlanT k o m)
instance GHC.Base.Alternative (Data.Machine.Plan.PlanT k o m)
instance GHC.Base.Monad (Data.Machine.Plan.PlanT k o m)
instance Control.Monad.Fail.MonadFail (Data.Machine.Plan.PlanT k o m)
instance GHC.Base.MonadPlus (Data.Machine.Plan.PlanT k o m)
instance Control.Monad.Trans.Class.MonadTrans (Data.Machine.Plan.PlanT k o)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Data.Machine.Plan.PlanT k o m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Data.Machine.Plan.PlanT k o m)
instance Control.Monad.Reader.Class.MonadReader e m => Control.Monad.Reader.Class.MonadReader e (Data.Machine.Plan.PlanT k o m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Data.Machine.Plan.PlanT k o m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Data.Machine.Plan.PlanT k o m)


module Data.Machine.Type

-- | A <a>MachineT</a> reads from a number of inputs and may yield results
--   before stopping with monadic side-effects.
newtype MachineT m k o
MachineT :: m (Step k o (MachineT m k o)) -> MachineT m k o
[runMachineT] :: MachineT m k o -> m (Step k o (MachineT m k o))

-- | This is the base functor for a <a>Machine</a> or <a>MachineT</a>.
--   
--   Note: A <a>Machine</a> is usually constructed from <a>Plan</a>, so it
--   does not need to be CPS'd.
data Step k o r
Stop :: Step k o r
Yield :: o -> r -> Step k o r
Await :: (t -> r) -> k t -> r -> Step k o r

-- | A <a>Machine</a> reads from a number of inputs and may yield results
--   before stopping.
--   
--   A <a>Machine</a> can be used as a <tt><a>MachineT</a> m</tt> for any
--   <tt><a>Monad</a> m</tt>.
type Machine k o = forall m. Monad m => MachineT m k o

-- | Stop feeding input into model, taking only the effects.
runT_ :: Monad m => MachineT m k b -> m ()

-- | Stop feeding input into model and extract an answer
runT :: Monad m => MachineT m k b -> m [b]

-- | Run a pure machine and extract an answer.
run :: MachineT Identity k b -> [b]

-- | <pre>
--   <a>runMachine</a> = <a>runIdentity</a> . <a>runMachineT</a>
--   </pre>
runMachine :: MachineT Identity k o -> Step k o (MachineT Identity k o)

-- | Pack a <a>Step</a> of a <a>Machine</a> into a <a>Machine</a>.
encased :: Monad m => Step k o (MachineT m k o) -> MachineT m k o

-- | Compile a machine to a model.
construct :: Monad m => PlanT k o m a -> MachineT m k o

-- | Generates a model that runs a machine until it stops, then start it up
--   again.
--   
--   <pre>
--   <a>repeatedly</a> m = <a>construct</a> (<a>forever</a> m)
--   </pre>
repeatedly :: Monad m => PlanT k o m a -> MachineT m k o

-- | Unfold a stateful PlanT into a MachineT.
unfoldPlan :: Monad m => s -> (s -> PlanT k o m s) -> MachineT m k o

-- | Evaluate a machine until it stops, and then yield answers according to
--   the supplied model.
before :: Monad m => MachineT m k o -> PlanT k o m a -> MachineT m k o

-- | Incorporate a <a>Plan</a> into the resulting machine.
preplan :: Monad m => PlanT k o m (MachineT m k o) -> MachineT m k o
deconstruct :: Monad m => MachineT m k (Either a o) -> PlanT k o m a

-- | Use a predicate to mark a yielded value as the terminal value of this
--   <a>Machine</a>. This is useful in combination with <a>deconstruct</a>
--   to combine <a>Plan</a>s.
tagDone :: Monad m => (o -> Bool) -> MachineT m k o -> MachineT m k (Either o o)

-- | Use a function to produce and mark a yielded value as the terminal
--   value of a <a>Machine</a>. All yielded values for which the given
--   function returns <a>Nothing</a> are yielded down the pipeline, but the
--   first value for which the function returns a <a>Just</a> value will be
--   returned by a <a>Plan</a> created via <a>deconstruct</a>.
finishWith :: Monad m => (o -> Maybe r) -> MachineT m k o -> MachineT m k (Either r o)

-- | Connect different kinds of machines.
--   
--   <pre>
--   <a>fit</a> <a>id</a> = <a>id</a>
--   </pre>
fit :: Monad m => (forall a. k a -> k' a) -> MachineT m k o -> MachineT m k' o
fitM :: (Monad m, Monad m') => (forall a. m a -> m' a) -> MachineT m k o -> MachineT m' k o

-- | Given a handle, ignore all other inputs and just stream input from
--   that handle.
--   
--   <pre>
--   <a>pass</a> <a>id</a> :: <a>Process</a> a a
--   <a>pass</a> <a>L</a>  :: <a>Tee</a> a b a
--   <a>pass</a> <a>R</a>  :: <a>Tee</a> a b b
--   <a>pass</a> <a>X</a>  :: <a>Wye</a> a b a
--   <a>pass</a> <a>Y</a>  :: <a>Wye</a> a b b
--   <a>pass</a> <a>Z</a>  :: <a>Wye</a> a b (Either a b)
--   </pre>
pass :: k o -> Machine k o

-- | Run a machine with no input until it stops, then behave as another
--   machine.
starve :: Monad m => MachineT m k0 b -> MachineT m k b -> MachineT m k b

-- | This is a stopped <a>Machine</a>
stopped :: Machine k b

-- | Transform a <a>Machine</a> by looking at a single step of that
--   machine.
stepMachine :: Monad m => MachineT m k o -> (Step k o (MachineT m k o) -> MachineT m k' o') -> MachineT m k' o'

-- | An input type that supports merging requests from multiple machines.
class Appliance k
applied :: (Appliance k, Monad m) => MachineT m k (a -> b) -> MachineT m k a -> MachineT m k b
instance (GHC.Base.Monad m, Data.Machine.Type.Appliance k) => GHC.Base.Applicative (Data.Machine.Type.MachineT m k)
instance GHC.Base.Monad m => GHC.Base.Functor (Data.Machine.Type.MachineT m k)
instance GHC.Base.Monad m => Data.Pointed.Pointed (Data.Machine.Type.MachineT m k)
instance GHC.Base.Monad m => GHC.Base.Semigroup (Data.Machine.Type.MachineT m k o)
instance GHC.Base.Monad m => GHC.Base.Monoid (Data.Machine.Type.MachineT m k o)
instance (m GHC.Types.~ Data.Functor.Identity.Identity) => Data.Foldable.Foldable (Data.Machine.Type.MachineT m k)
instance GHC.Base.Functor (Data.Machine.Type.Step k o)


module Data.Machine.Stack

-- | This is a simple process type that knows how to push back input.
data Stack a r
[Push] :: a -> Stack a ()
[Pop] :: Stack a a

-- | Stream outputs from one <a>Machine</a> into another with the
--   possibility of pushing inputs back.
stack :: Monad m => MachineT m k a -> MachineT m (Stack a) o -> MachineT m k o

-- | Peek at the next value in the input stream without consuming it
peek :: Plan (Stack a) b a

-- | Pop the next value in the input stream
pop :: Plan (Stack a) b a

-- | Push back into the input stream
push :: a -> Plan (Stack a) b ()

module Data.Machine.Runner

-- | Right fold over a stream. This will be lazy if the underlying monad
--   is.
--   
--   <pre>
--   runT = foldrT (:) []
--   </pre>
foldrT :: Monad m => (o -> b -> b) -> b -> MachineT m k o -> m b

-- | Strict left fold over a stream.
foldlT :: Monad m => (b -> o -> b) -> b -> MachineT m k o -> m b

-- | Strict fold over a stream. Items are accumulated on the right:
--   
--   <pre>
--   ... ((f o1 &lt;&gt; f o2) &lt;&gt; f o3) ...
--   </pre>
--   
--   Where this is expensive, use the dual monoid instead.
foldMapT :: (Monad m, Monoid r) => (o -> r) -> MachineT m k o -> m r

-- | Strict fold over a monoid stream. Items are accumulated on the right:
--   
--   <pre>
--   ... ((o1 &lt;&gt; o2) &lt;&gt; o3) ...
--   </pre>
--   
--   Where this is expensive, use the dual monoid instead.
--   
--   <pre>
--   foldT = foldMapT id
--   </pre>
foldT :: (Monad m, Monoid o) => MachineT m k o -> m o

-- | Run a machine with no input until it yields for the first time, then
--   stop it. This is intended primarily for use with accumulating
--   machines, such as the ones produced by <tt>fold</tt> or <tt>fold1</tt>
--   
--   <pre>
--   runT1 m = getFirst <a>$</a> foldMapT (First . Just) (m ~&gt; taking 1)
--   </pre>
runT1 :: Monad m => MachineT m k o -> m (Maybe o)

-- | Stop feeding input into model and extract an answer
runT :: Monad m => MachineT m k b -> m [b]

-- | Stop feeding input into model, taking only the effects.
runT_ :: Monad m => MachineT m k b -> m ()


module Data.Machine.Process

-- | A <tt><a>Process</a> a b</tt> is a stream transducer that can consume
--   values of type <tt>a</tt> from its input, and produce values of type
--   <tt>b</tt> for its output.
type Process a b = Machine (Is a) b

-- | A <tt><a>ProcessT</a> m a b</tt> is a stream transducer that can
--   consume values of type <tt>a</tt> from its input, and produce values
--   of type <tt>b</tt> and has side-effects in the <a>Monad</a>
--   <tt>m</tt>.
type ProcessT m a b = MachineT m (Is a) b

-- | An <a>Automaton</a> can be automatically lifted into a <a>Process</a>
class Automaton k
auto :: Automaton k => k a b -> Process a b
class AutomatonM x
autoT :: (AutomatonM x, Monad m) => x m a b -> ProcessT m a b

-- | Convert a machine into a process, with a little bit of help.
--   
--   <pre>
--   choose :: <a>T</a> a b x -&gt; (a, b) -&gt; x
--   choose t = case t of
--     <a>L</a> -&gt; <a>fst</a>
--     <a>R</a> -&gt; <a>snd</a>
--   
--   <a>process</a> choose :: <a>Tee</a> a b c -&gt; <a>Process</a> (a, b) c
--   <a>process</a> choose :: <a>Tee</a> a b c -&gt; <a>Process</a> (a, b) c
--   <a>process</a> (<a>const</a> <a>id</a>) :: <a>Process</a> a b -&gt; <a>Process</a> a b
--   </pre>
process :: Monad m => (forall a. k a -> i -> a) -> MachineT m k o -> ProcessT m i o

-- | Build a new <a>Machine</a> by adding a <a>Process</a> to the output of
--   an old <a>Machine</a>
--   
--   <pre>
--   (<a>&lt;~</a>) :: <a>Process</a> b c -&gt; <a>Process</a> a b -&gt; <a>Process</a> a c
--   (<a>&lt;~</a>) :: <a>Process</a> c d -&gt; <a>Tee</a> a b c -&gt; <a>Tee</a> a b d
--   (<a>&lt;~</a>) :: <a>Process</a> b c -&gt; <a>Machine</a> k b -&gt; <a>Machine</a> k c
--   </pre>
(<~) :: Monad m => ProcessT m b c -> MachineT m k b -> MachineT m k c
infixr 9 <~

-- | Flipped (<a>&lt;~</a>).
(~>) :: Monad m => MachineT m k b -> ProcessT m b c -> MachineT m k c
infixl 9 ~>

-- | The trivial <a>Process</a> that simply repeats each input it receives.
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   echo :: Process a a
--   echo = repeatedly $ do
--     i &lt;- await
--     yield i
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ echo &lt;~ source [1..5]
--   [1,2,3,4,5]
--   </pre>
echo :: Process a a

-- | Feed a <a>Process</a> some input.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ supply [1,2,3] echo &lt;~ source [4..6]
--   [1,2,3,4,5,6]
--   </pre>
supply :: forall f m a b. (Foldable f, Monad m) => f a -> ProcessT m a b -> ProcessT m a b

-- | A <a>Process</a> that prepends the elements of a <a>Foldable</a> onto
--   its input, then repeats its input from there.
prepended :: Foldable f => f a -> Process a a

-- | A <a>Process</a> that only passes through inputs that match a
--   predicate.
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   filtered :: (a -&gt; Bool) -&gt; Process a a
--   filtered p = repeatedly $ do
--     i &lt;- await
--     when (p i) $ yield i
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ filtered even &lt;~ source [1..5]
--   [2,4]
--   </pre>
filtered :: (a -> Bool) -> Process a a

-- | A <a>Process</a> that drops the first <tt>n</tt>, then repeats the
--   rest.
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   dropping n = before echo $ replicateM_ n await
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ dropping 3 &lt;~ source [1..5]
--   [4,5]
--   </pre>
dropping :: Int -> Process a a

-- | A <a>Process</a> that passes through the first <tt>n</tt> elements
--   from its input then stops
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   taking n = construct . replicateM_ n $ await &gt;&gt;= yield
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ taking 3 &lt;~ source [1..5]
--   [1,2,3]
--   </pre>
taking :: Int -> Process a a

-- | A <a>Process</a> that drops elements while a predicate holds
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   droppingWhile :: (a -&gt; Bool) -&gt; Process a a
--   droppingWhile p = before echo loop where
--     loop = await &gt;&gt;= v -&gt; if p v then loop else yield v
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ droppingWhile (&lt; 3) &lt;~ source [1..5]
--   [3,4,5]
--   </pre>
droppingWhile :: (a -> Bool) -> Process a a

-- | A <a>Process</a> that passes through elements until a predicate ceases
--   to hold, then stops
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   takingWhile :: (a -&gt; Bool) -&gt; Process a a
--   takingWhile p = repeatedly $ await &gt;&gt;= v -&gt; if p v then yield v else stop
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ takingWhile (&lt; 3) &lt;~ source [1..5]
--   [1,2]
--   </pre>
takingWhile :: (a -> Bool) -> Process a a

-- | A <a>Process</a> that passes through elements unwrapped from
--   <a>Just</a> until a <a>Nothing</a> is found, then stops.
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   takingJusts :: Process (Maybe a) a
--   takingJusts = repeatedly $ await &gt;&gt;= maybe stop yield
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ takingJusts &lt;~ source [Just 1, Just 2, Nothing, Just 3, Just 4]
--   [1,2]
--   </pre>
takingJusts :: Process (Maybe a) a

-- | Chunk up the input into <tt>n</tt> element lists.
--   
--   Avoids returning empty lists and deals with the truncation of the
--   final group.
--   
--   An approximation of this can be constructed from a plan with
--   
--   <pre>
--   buffered :: Int -&gt; Process a [a]
--   buffered = repeatedly . go [] where
--     go acc 0 = yield (reverse acc)
--     go acc n = do
--       i <a>await &lt;|</a> yield (reverse acc) *&gt; stop
--       go (i:acc) $! n-1
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ buffered 3 &lt;~ source [1..6]
--   [[1,2,3],[4,5,6]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run $ buffered 3 &lt;~ source [1..5]
--   [[1,2,3],[4,5]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run $ buffered 3 &lt;~ source []
--   []
--   </pre>
buffered :: Int -> Process a [a]

-- | Break each input into pieces that are fed downstream individually.
--   
--   Alias for <tt>asParts</tt>
flattened :: Foldable f => Process (f a) a

-- | Construct a <a>Process</a> from a left-folding operation.
--   
--   Like <a>scan</a>, but only yielding the final value.
--   
--   It may be useful to consider this alternative signature
--   
--   <pre>
--   <a>fold</a> :: (a -&gt; b -&gt; a) -&gt; a -&gt; Process b a
--   </pre>
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   fold :: Category k =&gt; (a -&gt; b -&gt; a) -&gt; a -&gt; Machine (k b) a
--   fold func seed = construct $ go seed where
--     go cur = do
--       next <a>await &lt;|</a> yield cur *&gt; stop
--       go $! func cur next
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ fold (+) 0 &lt;~ source [1..5]
--   [15]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run $ fold (\a _ -&gt; a + 1) 0 &lt;~ source [1..5]
--   [5]
--   </pre>
fold :: Category k => (a -> b -> a) -> a -> Machine (k b) a

-- | <a>fold1</a> is a variant of <a>fold</a> that has no starting value
--   argument
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   fold1 :: Category k =&gt; (a -&gt; a -&gt; a) -&gt; Machine (k a) a
--   fold1 func = construct $ await &gt;&gt;= go where
--     go cur = do
--       next <a>await &lt;|</a> yield cur *&gt; stop
--       go $! func cur next
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ fold1 (+) &lt;~ source [1..5]
--   [15]
--   </pre>
fold1 :: Category k => (a -> a -> a) -> Machine (k a) a

-- | Construct a <a>Process</a> from a left-scanning operation.
--   
--   Like <a>fold</a>, but yielding intermediate values.
--   
--   It may be useful to consider this alternative signature
--   
--   <pre>
--   <a>scan</a> :: (a -&gt; b -&gt; a) -&gt; a -&gt; Process b a
--   </pre>
--   
--   For stateful <a>scan</a> use <a>auto</a> with
--   <a>Data.Machine.Mealy</a> machine. This can be constructed from a plan
--   with
--   
--   <pre>
--   scan :: Category k =&gt; (a -&gt; b -&gt; a) -&gt; a -&gt; Machine (k b) a
--   scan func seed = construct $ go seed where
--     go cur = do
--       yield cur
--       next &lt;- await
--       go $! func cur next
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ scan (+) 0 &lt;~ source [1..5]
--   [0,1,3,6,10,15]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run $ scan (\a _ -&gt; a + 1) 0 &lt;~ source [1..5]
--   [0,1,2,3,4,5]
--   </pre>
scan :: Category k => (a -> b -> a) -> a -> Machine (k b) a

-- | <a>scan1</a> is a variant of <a>scan</a> that has no starting value
--   argument
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   scan1 :: Category k =&gt; (a -&gt; a -&gt; a) -&gt; Machine (k a) a
--   scan1 func = construct $ await &gt;&gt;= go where
--     go cur = do
--       yield cur
--       next &lt;- await
--       go $! func cur next
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ scan1 (+) &lt;~ source [1..5]
--   [1,3,6,10,15]
--   </pre>
scan1 :: Category k => (a -> a -> a) -> Machine (k a) a

-- | Like <a>scan</a> only uses supplied function to map and uses Monoid
--   for associative operation
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ mapping getSum &lt;~ scanMap Sum &lt;~ source [1..5]
--   [0,1,3,6,10,15]
--   </pre>
scanMap :: (Category k, Monoid b) => (a -> b) -> Machine (k a) b

-- | Break each input into pieces that are fed downstream individually.
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   asParts :: Foldable f =&gt; Process (f a) a
--   asParts = repeatedly $ await &gt;&gt;= traverse_ yield
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ asParts &lt;~ source [[1..3],[4..6]]
--   [1,2,3,4,5,6]
--   </pre>
asParts :: Foldable f => Process (f a) a

-- | <tt>sinkPart_ toParts sink</tt> creates a process that uses the
--   <tt>toParts</tt> function to break input into a tuple of
--   <tt>(passAlong, sinkPart)</tt> for which the second projection is
--   given to the supplied <tt>sink</tt> <a>ProcessT</a> (that produces no
--   output) while the first projection is passed down the pipeline.
sinkPart_ :: Monad m => (a -> (b, c)) -> ProcessT m c Void -> ProcessT m a b

-- | Apply a monadic function to each element of a <a>ProcessT</a>.
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   autoM :: Monad m =&gt; (a -&gt; m b) -&gt; ProcessT m a b
--   autoM :: (Category k, Monad m) =&gt; (a -&gt; m b) -&gt; MachineT m (k a) b
--   autoM f = repeatedly $ await &gt;&gt;= lift . f &gt;&gt;= yield
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; runT $ autoM Left &lt;~ source [3, 4]
--   Left 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runT $ autoM Right &lt;~ source [3, 4]
--   Right [3,4]
--   </pre>
autoM :: (Category k, Monad m) => (a -> m b) -> MachineT m (k a) b

-- | Skip all but the final element of the input
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   <a>final</a> :: <a>Process</a> a a
--   final :: Category k =&gt; Machine (k a) a
--   final = construct $ await &gt;&gt;= go where
--     go prev = do
--       next <a>await &lt;|</a> yield prev *&gt; stop
--       go next
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; runT $ final &lt;~ source [1..10]
--   [10]
--   
--   &gt;&gt;&gt; runT $ final &lt;~ source []
--   []
--   </pre>
final :: Category k => Machine (k a) a

-- | Skip all but the final element of the input. If the input is empty,
--   the default value is emitted
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   <a>finalOr</a> :: a -&gt; <a>Process</a> a a
--   finalOr :: Category k =&gt; a -&gt; Machine (k a) a
--   finalOr = construct . go where
--     go prev = do
--       next <a>await &lt;|</a> yield prev *&gt; stop
--       go next
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; runT $ finalOr (-1) &lt;~ source [1..10]
--   [10]
--   
--   &gt;&gt;&gt; runT $ finalOr (-1) &lt;~ source []
--   [-1]
--   </pre>
finalOr :: Category k => a -> Machine (k a) a

-- | Intersperse an element between the elements of the input
--   
--   <pre>
--   <a>intersperse</a> :: a -&gt; <a>Process</a> a a
--   </pre>
intersperse :: Category k => a -> Machine (k a) a

-- | Return the maximum value from the input
largest :: (Category k, Ord a) => Machine (k a) a

-- | Return the minimum value from the input
smallest :: (Category k, Ord a) => Machine (k a) a

-- | Convert a stream of actions to a stream of values
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   sequencing :: Monad m =&gt; (a -&gt; m b) -&gt; ProcessT m a b
--   sequencing :: (Category k, Monad m) =&gt; MachineT m (k (m a)) a
--   sequencing = repeatedly $ do
--     ma &lt;- await
--     a  &lt;- lift ma
--     yield a
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; runT $ sequencing &lt;~ source [Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runT $ sequencing &lt;~ source [Just 3, Just 4]
--   Just [3,4]
--   </pre>
sequencing :: (Category k, Monad m) => MachineT m (k (m a)) a

-- | Apply a function to all values coming from the input
--   
--   This can be constructed from a plan with
--   
--   <pre>
--   mapping :: Category k =&gt; (a -&gt; b) -&gt; Machine (k a) b
--   mapping f = repeatedly $ await &gt;&gt;= yield . f
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; runT $ mapping (*2) &lt;~ source [1..3]
--   [2,4,6]
--   </pre>
mapping :: Category k => (a -> b) -> Machine (k a) b

-- | Apply an effectful to all values coming from the input.
--   
--   Alias to <a>autoM</a>.
traversing :: (Category k, Monad m) => (a -> m b) -> MachineT m (k a) b

-- | Parse <a>Read</a>able values, only emitting the value if the parse
--   succceeds. This <a>Machine</a> stops at first parsing error
reading :: (Category k, Read a) => Machine (k String) a

-- | Convert <a>Show</a>able values to <a>String</a>s
showing :: (Category k, Show a) => Machine (k a) String

-- | <a>strippingPrefix</a> <tt>mp mb</tt> Drops the given prefix from
--   <tt>mp</tt>. It stops if <tt>mb</tt> did not start with the prefix
--   given, or continues streaming after the prefix, if <tt>mb</tt> did.
strippingPrefix :: (Eq b, Monad m) => MachineT m (k a) b -> MachineT m (k a) b -> MachineT m (k a) b
instance Data.Machine.Process.AutomatonM Control.Arrow.Kleisli
instance Data.Machine.Process.Automaton (->)
instance Data.Machine.Process.Automaton Data.Machine.Is.Is


module Data.Machine.Source

-- | A <a>Source</a> never reads from its inputs.
type Source b = forall k. Machine k b

-- | A <a>SourceT</a> never reads from its inputs, but may have monadic
--   side-effects.
type SourceT m b = forall k. MachineT m k b

-- | Generate a <a>Source</a> from any <a>Foldable</a> container.
--   
--   This can be constructed from a plan with <tt> source :: Foldable f
--   =&gt; f b -&gt; Source b source = construct (traverse_ yield xs) </tt>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ source [1,2]
--   [1,2]
--   </pre>
source :: Foldable f => f b -> Source b

-- | Repeat the same value, over and over.
--   
--   This can be constructed from a plan with <tt> repeated :: o -&gt;
--   Source o repeated = repeatedly . yield </tt>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ taking 5 &lt;~ repeated 1
--   [1,1,1,1,1]
--   </pre>
repeated :: o -> Source o

-- | Loop through a <a>Foldable</a> container over and over.
--   
--   This can be constructed from a plan with <tt> cycled :: Foldable f
--   =&gt; f b -&gt; Source b cycled = repeatedly (traverse_ yield xs)
--   </tt>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ taking 5 &lt;~ cycled [1,2]
--   [1,2,1,2,1]
--   </pre>
cycled :: Foldable f => f b -> Source b

-- | You can transform a <a>Source</a> with a <a>Process</a>.
--   
--   Alternately you can view this as capping the <a>Source</a> end of a
--   <a>Process</a>, yielding a new <a>Source</a>.
--   
--   <pre>
--   <a>cap</a> l r = l <a>&lt;~</a> r
--   </pre>
cap :: Process a b -> Source a -> Source b

-- | You can transform any <a>MachineT</a> into a <a>SourceT</a>, blocking
--   its input.
--   
--   This is used by capT, and capWye, and allows an efficient way to plug
--   together machines of different input languages.
plug :: Monad m => MachineT m k o -> SourceT m o

-- | <a>iterated</a> <tt>f x</tt> returns an infinite source of repeated
--   applications of <tt>f</tt> to <tt>x</tt>
iterated :: (a -> a) -> a -> Source a

-- | <a>replicated</a> <tt>n x</tt> is a source of <tt>x</tt> emitted
--   <tt>n</tt> time(s)
replicated :: Int -> a -> Source a

-- | Enumerate from a value to a final value, inclusive, via <tt>succ</tt>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; run $ enumerateFromTo 1 3
--   [1,2,3]
--   </pre>
enumerateFromTo :: Enum a => a -> a -> Source a

-- | <a>unfold</a> <tt>k seed</tt> The function takes the element and
--   returns Nothing if it is done producing values or returns Just (a,r),
--   in which case, <tt>a</tt> is <a>yield</a>ed and <tt>r</tt> is used as
--   the next element in a recursive call.
unfold :: (r -> Maybe (a, r)) -> r -> Source a

-- | Effectful <a>unfold</a> variant.
unfoldT :: Monad m => (r -> m (Maybe (a, r))) -> r -> SourceT m a


module Data.Machine.Tee

-- | A <a>Machine</a> that can read from two input stream in a
--   deterministic manner.
type Tee a b c = Machine (T a b) c

-- | A <a>Machine</a> that can read from two input stream in a
--   deterministic manner with monadic side-effects.
type TeeT m a b c = MachineT m (T a b) c

-- | The input descriptor for a <a>Tee</a> or <a>TeeT</a>
data T a b c
[L] :: T a b a
[R] :: T a b b

-- | Compose a pair of pipes onto the front of a Tee.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Machine.Source
--   
--   &gt;&gt;&gt; run $ tee (source [1..]) (source ['a'..'c']) zipping
--   [(1,'a'),(2,'b'),(3,'c')]
--   </pre>
tee :: Monad m => ProcessT m a a' -> ProcessT m b b' -> TeeT m a' b' c -> TeeT m a b c

-- | `teeT mt ma mb` Use a <a>Tee</a> to interleave or combine the outputs
--   of <tt>ma</tt> and <tt>mb</tt>.
--   
--   The resulting machine will draw from a single source.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Machine.Source
--   
--   &gt;&gt;&gt; run $ teeT zipping echo echo &lt;~ source [1..5]
--   [(1,2),(3,4)]
--   </pre>
teeT :: Monad m => TeeT m a b c -> MachineT m k a -> MachineT m k b -> MachineT m k c

-- | Precompose a pipe onto the left input of a tee.
addL :: Monad m => ProcessT m a b -> TeeT m b c d -> TeeT m a c d

-- | Precompose a pipe onto the right input of a tee.
addR :: Monad m => ProcessT m b c -> TeeT m a c d -> TeeT m a b d

-- | Tie off one input of a tee by connecting it to a known source.
capL :: Monad m => SourceT m a -> TeeT m a b c -> ProcessT m b c

-- | Tie off one input of a tee by connecting it to a known source.
capR :: Monad m => SourceT m b -> TeeT m a b c -> ProcessT m a c

-- | Tie off both inputs to a tee by connecting them to known sources. This
--   is recommended over capping each side separately, as it is far more
--   efficient.
capT :: Monad m => SourceT m a -> SourceT m b -> TeeT m a b c -> SourceT m c

-- | wait for both the left and the right sides of a T and then merge them
--   with f.
zipWithT :: (a -> b -> c) -> PlanT (T a b) c m ()

-- | Zip together two inputs, then apply the given function, halting as
--   soon as either input is exhausted. This implementation reads from the
--   left, then the right
zipWith :: (a -> b -> c) -> Tee a b c

-- | Zip together two inputs, halting as soon as either input is exhausted.
zipping :: Tee a b (a, b)


-- | Allows bidirectional communication between two MachineT. Exposed the
--   same interface of Pipes library.
module Data.Machine.Pipe
data Exchange a' a b' b c
[Request] :: a' -> Exchange a' a b' b a
[Respond] :: b -> Exchange a' a b' b b'
type Proxy a' a b' b m c = MachineT m (Exchange a' a b' b) c

-- | <a>Effect</a>s neither <a>request</a> nor <a>respond</a>
type Effect m r = Proxy Void () () Void m r

-- | <tt>Client a' a</tt> sends requests of type <tt>a'</tt> and receives
--   responses of type <tt>a</tt>. <a>Client</a>s only <a>request</a> and
--   never <a>respond</a>.
type Client a' a m r = Proxy a' a () Void m r

-- | <tt>Server b' b</tt> receives requests of type <tt>b'</tt> and sends
--   responses of type <tt>b</tt>. <a>Server</a>s only <a>respond</a> and
--   never <a>request</a>.
type Server b' b m r = Proxy Void () b' b m r

-- | Like <a>Effect</a>, but with a polymorphic type
type Effect' m r = forall x' x y' y. Proxy x' x y' y m r

-- | Like <a>Server</a>, but with a polymorphic type
type Server' b' b m r = forall x' x. Proxy x' x b' b m r

-- | Like <a>Client</a>, but with a polymorphic type
type Client' a' a m r = forall y' y. Proxy a' a y' y m r

-- | Send a value of type a' upstream and block waiting for a reply of type
--   a. <a>request</a> is the identity of the request category.
request :: a' -> PlanT (Exchange a' a y' y) o m a

-- | Send a value of type a downstream and block waiting for a reply of
--   type a' <a>respond</a> is the identity of the respond category.
respond :: a -> PlanT (Exchange x' x a' a) o m a'

-- | Forward responses followed by requests. <a>push</a> is the identity of
--   the push category.
push :: Monad m => a -> Proxy a' a a' a m r

-- | Compose two proxies blocked while <a>request</a>ing data, creating a
--   new proxy blocked while <a>request</a>ing data. (<a>&gt;~&gt;</a>) is
--   the composition operator of the push category.
(>~>) :: Monad m => (_a -> Proxy a' a b' b m r) -> (b -> Proxy b' b c' c m r) -> _a -> Proxy a' a c' c m r
infixl 8 >~>

-- | (p &gt;&gt;~ f) pairs each <a>respond</a> in p with an <a>request</a>
--   in f.
(>>~) :: Monad m => Proxy a' a b' b m r -> (b -> Proxy b' b c' c m r) -> Proxy a' a c' c m r
infixl 7 >>~

-- | Forward requests followed by responses. <a>pull</a> is the identity of
--   the pull category.
pull :: Monad m => a' -> Proxy a' a a' a m r

-- | Compose two proxies blocked in the middle of <a>respond</a>ing,
--   creating a new proxy blocked in the middle of <a>respond</a>ing.
--   (<a>&gt;+&gt;</a>) is the composition operator of the pull category.
(>+>) :: Monad m => (b' -> Proxy a' a b' b m r) -> (_c' -> Proxy b' b c' c m r) -> _c' -> Proxy a' a c' c m r
infixl 7 >+>

-- | (f +&gt;&gt; p) pairs each <a>request</a> in p with a <a>respond</a>
--   in f.
(+>>) :: Monad m => (b' -> Proxy a' a b' b m r) -> Proxy b' b c' c m r -> Proxy a' a c' c m r
infixr 6 +>>

-- | It is impossible for an <a>Exchange</a> to hold a <a>Void</a> value.
absurdExchange :: Exchange Void a b Void t -> c

-- | Run a self-contained <a>Effect</a>, converting it back to the base
--   monad.
runEffect :: Monad m => Effect m o -> m [o]

-- | Like <a>runEffect</a> but discarding any produced value.
runEffect_ :: Monad m => Effect m o -> m ()


-- | <a>http://en.wikipedia.org/wiki/Moore_machine</a>
module Data.Machine.Moore

-- | <a>Moore</a> machines
data Moore a b
Moore :: b -> (a -> Moore a b) -> Moore a b

-- | Accumulate the input as a sequence.
logMoore :: Monoid m => Moore m m

-- | Construct a Moore machine from a state valuation and transition
--   function
unfoldMoore :: (s -> (b, a -> s)) -> s -> Moore a b
instance Data.Machine.Process.Automaton Data.Machine.Moore.Moore
instance GHC.Base.Functor (Data.Machine.Moore.Moore a)
instance Data.Profunctor.Unsafe.Profunctor Data.Machine.Moore.Moore
instance GHC.Base.Applicative (Data.Machine.Moore.Moore a)
instance Data.Pointed.Pointed (Data.Machine.Moore.Moore a)
instance GHC.Base.Monad (Data.Machine.Moore.Moore a)
instance Data.Copointed.Copointed (Data.Machine.Moore.Moore a)
instance Control.Comonad.Comonad (Data.Machine.Moore.Moore a)
instance Control.Comonad.ComonadApply (Data.Machine.Moore.Moore a)
instance Data.Distributive.Distributive (Data.Machine.Moore.Moore a)
instance Data.Functor.Rep.Representable (Data.Machine.Moore.Moore a)
instance Data.Profunctor.Sieve.Cosieve Data.Machine.Moore.Moore []
instance Data.Profunctor.Strong.Costrong Data.Machine.Moore.Moore
instance Data.Profunctor.Rep.Corepresentable Data.Machine.Moore.Moore
instance Control.Monad.Fix.MonadFix (Data.Machine.Moore.Moore a)
instance Control.Monad.Zip.MonadZip (Data.Machine.Moore.Moore a)
instance Control.Monad.Reader.Class.MonadReader [a] (Data.Machine.Moore.Moore a)
instance Data.Profunctor.Closed.Closed Data.Machine.Moore.Moore
instance GHC.Base.Semigroup b => GHC.Base.Semigroup (Data.Machine.Moore.Moore a b)
instance GHC.Base.Monoid b => GHC.Base.Monoid (Data.Machine.Moore.Moore a b)


-- | <a>http://en.wikipedia.org/wiki/Mealy_machine</a>
module Data.Machine.Mealy

-- | <a>Mealy</a> machines
--   
--   <h4>Examples</h4>
--   
--   We can enumerate inputs:
--   
--   <pre>
--   &gt;&gt;&gt; let countingMealy = unfoldMealy (\i x -&gt; ((i, x), i + 1)) 0
--   
--   &gt;&gt;&gt; run (auto countingMealy &lt;~ source "word")
--   [(0,'w'),(1,'o'),(2,'r'),(3,'d')]
--   </pre>
newtype Mealy a b
Mealy :: (a -> (b, Mealy a b)) -> Mealy a b
[runMealy] :: Mealy a b -> a -> (b, Mealy a b)

-- | A <a>Mealy</a> machine modeled with explicit state.
unfoldMealy :: (s -> a -> (b, s)) -> s -> Mealy a b

-- | Accumulate history.
logMealy :: Semigroup a => Mealy a a
instance GHC.Base.Functor (Data.Machine.Mealy.Mealy a)
instance GHC.Base.Applicative (Data.Machine.Mealy.Mealy a)
instance Data.Pointed.Pointed (Data.Machine.Mealy.Mealy a)
instance Data.Functor.Extend.Extend (Data.Machine.Mealy.Mealy a)
instance Data.Profunctor.Unsafe.Profunctor Data.Machine.Mealy.Mealy
instance Data.Machine.Process.Automaton Data.Machine.Mealy.Mealy
instance Control.Category.Category Data.Machine.Mealy.Mealy
instance Control.Arrow.Arrow Data.Machine.Mealy.Mealy
instance Control.Arrow.ArrowChoice Data.Machine.Mealy.Mealy
instance Data.Profunctor.Strong.Strong Data.Machine.Mealy.Mealy
instance Data.Profunctor.Choice.Choice Data.Machine.Mealy.Mealy
instance Control.Arrow.ArrowApply Data.Machine.Mealy.Mealy
instance Data.Distributive.Distributive (Data.Machine.Mealy.Mealy a)
instance Data.Functor.Rep.Representable (Data.Machine.Mealy.Mealy a)
instance Data.Profunctor.Sieve.Cosieve Data.Machine.Mealy.Mealy GHC.Base.NonEmpty
instance Data.Profunctor.Strong.Costrong Data.Machine.Mealy.Mealy
instance Data.Profunctor.Rep.Corepresentable Data.Machine.Mealy.Mealy
instance Data.Profunctor.Closed.Closed Data.Machine.Mealy.Mealy
instance GHC.Base.Semigroup b => GHC.Base.Semigroup (Data.Machine.Mealy.Mealy a b)
instance GHC.Base.Monoid b => GHC.Base.Monoid (Data.Machine.Mealy.Mealy a b)


-- | Utilities for working with machines that run in transformed monads,
--   inspired by <tt>Pipes.Lift</tt>.
module Data.Machine.Lift

-- | Given an initial state and a <a>MachineT</a> that runs in
--   <tt><a>StateT</a> s m</tt>, produce a <a>MachineT</a> that runs in
--   <tt>m</tt>.
execStateM :: Monad m => s -> MachineT (StateT s m) k o -> MachineT m k o

-- | <a>catchExcept</a> allows a broken machine to be replaced without
--   stopping the assembly line.
catchExcept :: Monad m => MachineT (ExceptT e m) k o -> (e -> MachineT (ExceptT e m) k o) -> MachineT (ExceptT e m) k o

-- | Given an environment and a <a>MachineT</a> that runs in
--   <tt><a>ReaderT</a> e m</tt>, produce a <a>MachineT</a> that runs in
--   <tt>m</tt>.
runReaderM :: Monad m => e -> MachineT (ReaderT e m) k o -> MachineT m k o


module Data.Machine.Wye

-- | A <a>Machine</a> that can read from two input stream in a
--   non-deterministic manner.
type Wye a b c = Machine (Y a b) c

-- | A <a>Machine</a> that can read from two input stream in a
--   non-deterministic manner with monadic side-effects.
type WyeT m a b c = MachineT m (Y a b) c

-- | The input descriptor for a <a>Wye</a> or <a>WyeT</a>
data Y a b c
[X] :: Y a b a
[Y] :: Y a b b
[Z] :: Y a b (Either a b)

-- | Compose a pair of pipes onto the front of a <a>Wye</a>.
--   
--   Precompose a <a>Process</a> onto each input of a <a>Wye</a> (or
--   <a>WyeT</a>).
--   
--   This is left biased in that it tries to draw values from the <a>X</a>
--   input whenever they are available, and only draws from the <a>Y</a>
--   input when <a>X</a> would block.
wye :: Monad m => ProcessT m a a' -> ProcessT m b b' -> WyeT m a' b' c -> WyeT m a b c

-- | Precompose a pipe onto the left input of a wye.
addX :: Monad m => ProcessT m a b -> WyeT m b c d -> WyeT m a c d

-- | Precompose a pipe onto the right input of a wye.
addY :: Monad m => ProcessT m b c -> WyeT m a c d -> WyeT m a b d

-- | Tie off one input of a wye by connecting it to a known source.
capX :: Monad m => SourceT m a -> WyeT m a b c -> ProcessT m b c

-- | Tie off one input of a wye by connecting it to a known source.
capY :: Monad m => SourceT m b -> WyeT m a b c -> ProcessT m a c

-- | Tie off both inputs of a wye by connecting them to known sources.
capWye :: Monad m => SourceT m a -> SourceT m b -> WyeT m a b c -> SourceT m c


module Data.Machine


-- | <a>http://en.wikipedia.org/wiki/Mealy_machine</a>
--   <a>https://github.com/ivanperez-keera/dunai/blob/develop/src/Data/MonadicStreamFunction/Core.hs#L35</a>
--   <a>https://hackage.haskell.org/package/auto-0.4.3.0/docs/Control-Auto.html</a>
--   <a>https://hackage.haskell.org/package/varying-0.6.0.0/docs/Control-Varying-Core.html</a>
module Data.Machine.MealyT

-- | <a>Mealy</a> machine, with applicative effects
newtype MealyT m a b
MealyT :: (a -> m (b, MealyT m a b)) -> MealyT m a b
[runMealyT] :: MealyT m a b -> a -> m (b, MealyT m a b)
arrPure :: (a -> b) -> MealyT Identity a b
arrM :: Functor m => (a -> m b) -> MealyT m a b
upgrade :: Applicative m => Mealy a b -> MealyT m a b
scanMealyT :: Applicative m => (a -> b -> a) -> a -> MealyT m b a
scanMealyTM :: Functor m => (a -> b -> m a) -> a -> MealyT m b a
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Machine.MealyT.MealyT m a)
instance Data.Pointed.Pointed m => Data.Pointed.Pointed (Data.Machine.MealyT.MealyT m a)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Data.Machine.MealyT.MealyT m a)
instance GHC.Base.Functor m => Data.Profunctor.Unsafe.Profunctor (Data.Machine.MealyT.MealyT m)
instance GHC.Base.Monad m => Control.Category.Category (Data.Machine.MealyT.MealyT m)
instance GHC.Base.Monad m => Control.Arrow.Arrow (Data.Machine.MealyT.MealyT m)
instance Data.Machine.Process.AutomatonM Data.Machine.MealyT.MealyT
instance (GHC.Base.Semigroup b, GHC.Base.Applicative m) => GHC.Base.Semigroup (Data.Machine.MealyT.MealyT m a b)
instance (GHC.Base.Semigroup b, GHC.Base.Monoid b, GHC.Base.Applicative m) => GHC.Base.Monoid (Data.Machine.MealyT.MealyT m a b)


-- | <a>http://en.wikipedia.org/wiki/Moore_machine</a>
module Data.Machine.MooreT

-- | <a>Moore</a> machine, with applicative effects
newtype MooreT m a b
MooreT :: m (b, a -> MooreT m a b) -> MooreT m a b
[runMooreT] :: MooreT m a b -> m (b, a -> MooreT m a b)

-- | Construct a MooreT machine from a state valuation and transition
--   action
unfoldMooreT :: Functor m => (s -> m (b, a -> s)) -> s -> MooreT m a b
upgrade :: Applicative m => Moore a b -> MooreT m a b
hoist :: Functor n => (forall x. m x -> n x) -> MooreT m a b -> MooreT n a b
couple :: Monad m => MooreT m a b -> MealyT m b a -> m c
firstM :: (Functor m, Monad m) => (a' -> m a) -> MooreT m a b -> MooreT m a' b
secondM :: Monad m => (b -> m b') -> MooreT m a b -> MooreT m a b'
instance Data.Machine.Process.AutomatonM Data.Machine.MooreT.MooreT
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Machine.MooreT.MooreT m a)
instance GHC.Base.Functor m => Data.Profunctor.Unsafe.Profunctor (Data.Machine.MooreT.MooreT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Data.Machine.MooreT.MooreT m a)
instance GHC.Base.Applicative m => Data.Pointed.Pointed (Data.Machine.MooreT.MooreT m a)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Profunctor.Strong.Costrong (Data.Machine.MooreT.MooreT m)
instance (Data.Distributive.Distributive m, GHC.Base.Applicative m) => Data.Distributive.Distributive (Data.Machine.MooreT.MooreT m a)
instance (GHC.Base.Applicative m, GHC.Base.Semigroup b) => GHC.Base.Semigroup (Data.Machine.MooreT.MooreT m a b)
instance (GHC.Base.Applicative m, GHC.Base.Monoid b) => GHC.Base.Monoid (Data.Machine.MooreT.MooreT m a b)


-- | Split up input streams into groups with separator values and process
--   the groups with their own <a>MachineT</a>.
module Data.Machine.Group.General

-- | Using a function to signal group changes, run a machine independently
--   over each group with the value returned provided.
groupingOn :: Monad m => i -> (a -> a -> Maybe i) -> (i -> ProcessT m a b) -> ProcessT m a b

-- | Using a function to signal group changes, run a machine independently
--   over each group.
groupingOn_ :: Monad m => (a -> a -> Bool) -> ProcessT m a b -> ProcessT m a b

-- | Run a machine repeatedly over <tt>n</tt>-element segments of the
--   stream, providing an incrementing value to each run.
groupingN :: Monad m => Int -> (Int -> ProcessT m a b) -> ProcessT m a b

-- | Mark a transition point between two groups when a state passing
--   function returns a <a>Just</a> i. Examples
--   
--   <pre>
--   &gt;&gt;&gt; runT $ supply [1,3,3,2] (taggedState (-1) (\x y -&gt; (even x &lt;$ guard (x /= y), x)))
--   [Left False,Right 1,Left False,Right 3,Right 3,Left True,Right 2]
--   </pre>
taggedState :: Monad m => s -> (a -> s -> (Maybe i, s)) -> ProcessT m a (Either i a)

-- | Mark a transition point between two groups when an action returns a
--   <a>Just</a> i. Could be useful for breaking up a stream based on time
--   passed. Examples
--   
--   <pre>
--   &gt;&gt;&gt; let f x = do{ y &lt;- ask; return (even x &lt;$ guard (x &gt; y)) }
--   
--   &gt;&gt;&gt; flip runReader 1 . runT $ supply [1,3,3,2] (taggedM f)
--   [Right 1,Left False,Right 3,Left False,Right 3,Left True,Right 2]
--   </pre>
taggedM :: Monad m => (a -> m (Maybe i)) -> ProcessT m a (Either i a)

-- | Mark a transition point between two groups as a function of adjacent
--   elements, and insert the value returned as the separator. Examples
--   
--   <pre>
--   &gt;&gt;&gt; runT $ supply [1,3,3,2] (taggedOn (\x y -&gt; (x &lt; y) &lt;$ guard (x /= y)))
--   [Right 1,Left True,Right 3,Right 3,Left False,Right 2]
--   </pre>
taggedOn :: Monad m => (a -> a -> Maybe i) -> ProcessT m a (Either i a)

-- | Mark a transition point between two groups using an action on adjacent
--   elements, and insert the value returned as the separator. Examples
--   
--   <pre>
--   &gt;&gt;&gt; let f x y = do{ z &lt;- ask; return ((x + y &lt;$ guard (z &lt; x + y))) }
--   
--   &gt;&gt;&gt; flip runReader 5 . runT $ supply [1..5] (taggedOnM f)
--   [Right 1,Right 2,Right 3,Left 7,Right 4,Left 9,Right 5]
--   </pre>
taggedOnM :: Monad m => (a -> a -> m (Maybe i)) -> ProcessT m a (Either i a)

-- | Mark a transition point between two groups as a function of adjacent
--   elements. Examples
--   
--   <pre>
--   &gt;&gt;&gt; runT $ supply [1,2,2] (taggedOn_ (==))
--   [Right 1,Left (),Right 2,Right 2]
--   </pre>
taggedOn_ :: Monad m => (a -> a -> Bool) -> ProcessT m a (Either () a)

-- | Mark a transition point between two groups at every <tt>n</tt> values,
--   stepping the separator by a function. Examples
--   
--   <pre>
--   &gt;&gt;&gt; runT $ supply [1..5] (taggedAt 2 True not)
--   [Right 1,Right 2,Left True,Right 3,Right 4,Left False,Right 5]
--   </pre>
taggedAt :: Monad m => Int -> s -> (s -> s) -> ProcessT m a (Either s a)

-- | Mark a transition point between two groups at every <tt>n</tt> values.
--   Examples
--   
--   <pre>
--   &gt;&gt;&gt; runT $ supply [1..5] (taggedAt_ 2)
--   [Right 1,Right 2,Left (),Right 3,Right 4,Left (),Right 5]
--   </pre>
taggedAt_ :: Monad m => Int -> ProcessT m a (Either () a)

-- | Mark a transition point between two groups at every <tt>n</tt> values,
--   using the counter as the separator. Examples
--   
--   <pre>
--   &gt;&gt;&gt; runT $ supply [1..5] (taggedCount 2)
--   [Right 1,Right 2,Left 1,Right 3,Right 4,Left 2,Right 5]
--   </pre>
taggedCount :: Monad m => Int -> ProcessT m a (Either Int a)

-- | Run a machine multiple times over partitions of the input stream
--   specified by <a>Left</a> i values, passing the <tt>i</tt>s to each
--   <a>MachineT</a> run. Examples
--   
--   <pre>
--   &gt;&gt;&gt; let input = [Right 1, Right 2,Left 1, Right 3,Left 2, Right 4]
--   
--   &gt;&gt;&gt; runT $ supply input (partitioning 0 (\x -&gt; mapping (\y -&gt; (x,y))))
--   [(0,1),(0,2),(1,3),(2,4)]
--   </pre>
partitioning :: Monad m => i -> (i -> ProcessT m a b) -> ProcessT m (Either i a) b

-- | Run a machine multiple times over partitions of the input stream
--   specified by <a>Left</a> () values. Examples
--   
--   <pre>
--   &gt;&gt;&gt; let input = [Right 1,Left (),Right 3,Right 4,Left ()]
--   
--   &gt;&gt;&gt; runT $ supply input (partitioning_ (fold (flip (:)) []))
--   [[1],[4,3],[]]
--   </pre>
partitioning_ :: Monad m => ProcessT m a b -> ProcessT m (Either () a) b

-- | Run a machine with no input until it stops, then behave as another
--   machine.
starve :: Monad m => MachineT m k0 b -> MachineT m k b -> MachineT m k b

-- | Read inputs until a condition is met, then behave as cont with input
--   matching condition as first input of cont. If await fails, stop.
awaitUntil :: Monad m => (a -> Bool) -> (a -> ProcessT m a b) -> ProcessT m a b

module Data.Machine.Group

-- | Using a function to signal group changes, apply a machine
--   independently over each group.
groupingOn :: Monad m => (a -> a -> Bool) -> ProcessT m a b -> ProcessT m a b

-- | Mark a transition point between two groups as a function of adjacent
--   elements. Examples
--   
--   <pre>
--   &gt;&gt;&gt; runT $ supply [1,2,2] (taggedBy (==))
--   [Right 1,Left (),Right 2,Right 2]
--   </pre>
taggedBy :: Monad m => (a -> a -> Bool) -> ProcessT m a (Either () a)

-- | Run a machine multiple times over partitions of the input stream
--   specified by Left () values.
partitioning :: Monad m => ProcessT m a b -> ProcessT m (Either () a) b

-- | Run a machine with no input until it stops, then behave as another
--   machine.
starve :: Monad m => MachineT m k0 b -> MachineT m k b -> MachineT m k b

-- | Read inputs until a condition is met, then behave as cont with | input
--   matching condition as first input of cont. | If await fails, stop.
awaitUntil :: Monad m => (a -> Bool) -> (a -> ProcessT m a b) -> ProcessT m a b


-- | Provide a notion of fanout wherein a single input is passed to several
--   consumers.
module Data.Machine.Fanout

-- | Share inputs with each of a list of processes in lockstep. Any values
--   yielded by the processes are combined into a single yield from the
--   composite process.
fanout :: forall m a r. (Monad m, Semigroup r) => [ProcessT m a r] -> ProcessT m a r

-- | Share inputs with each of a list of processes in lockstep. If none of
--   the processes yields a value, the composite process will itself yield
--   <a>mempty</a>. The idea is to provide a handle on steps only executed
--   for their side effects. For instance, if you want to run a collection
--   of <a>ProcessT</a>s that await but don't yield some number of times,
--   you can use 'fanOutSteps . map (fmap (const ()))' followed by a
--   <a>taking</a> process.
fanoutSteps :: forall m a r. (Monad m, Monoid r) => [ProcessT m a r] -> ProcessT m a r
