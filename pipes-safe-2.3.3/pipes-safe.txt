-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Safety for the pipes ecosystem
--   
--   This package adds resource management and exception handling to the
--   <tt>pipes</tt> ecosystem.
--   
--   Notable features include:
--   
--   <ul>
--   <li><i>Resource Safety</i>: Guarantee finalization using
--   <tt>finally</tt>, <tt>bracket</tt> and more</li>
--   <li><i>Exception Safety</i>: Even against asynchronous
--   exceptions!</li>
--   <li><i>Laziness</i>: Only acquire resources when you need them</li>
--   <li><i>Promptness</i>: Finalize resources early when you are done with
--   them</li>
--   <li><i>Native Exception Handling</i>: Catch and resume from exceptions
--   inside pipes</li>
--   <li><i>No Buy-in</i>: Mix resource-safe pipes with unmanaged pipes
--   using <tt>hoist</tt></li>
--   </ul>
@package pipes-safe
@version 2.3.3


-- | This module provides an orphan <a>MonadMask</a> instance for
--   <a>Proxy</a> of the form:
--   
--   <pre>
--   instance (MonadMask m, MonadIO m) =&gt; MonadMask (Proxy a' a b' b m) where
--   </pre>
--   
--   Which is needed to implement the instance for MonadSafe for Proxy.
--   
--   This module also provides generalized versions of some
--   <a>MonadCatch</a> operations so that you can also protect against
--   premature termination of connected components. For example, if you
--   protect a <a>readFile</a> computation using <a>bracket</a> from this
--   module:
--   
--   <pre>
--   -- readFile.hs
--   import Pipes
--   import qualified Pipes.Prelude as P
--   import Pipes.Safe
--   import qualified System.IO as IO
--   import Prelude hiding (readFile)
--   
--   readFile :: FilePath -&gt; Producer' String (SafeT IO) ()
--   readFile file = bracket
--       (do h &lt;- IO.openFile file IO.ReadMode
--           putStrLn $ "{" ++ file ++ " open}"
--           return h )
--       (\h -&gt; do
--           IO.hClose h
--           putStrLn $ "{" ++ file ++ " closed}" )
--       P.fromHandle
--   </pre>
--   
--   ... then this generalized <a>bracket</a> will guard against both
--   exceptions and premature termination of other pipes:
--   
--   <pre>
--   &gt;&gt;&gt; runSafeT $ runEffect $ readFile "readFile.hs" &gt;-&gt; P.take 4 &gt;-&gt; P.stdoutLn
--   {readFile.hs open}
--   -- readFile.hs
--   import Pipes
--   import qualified Pipes.Prelude as P
--   import Pipes.Safe
--   {readFile.hs closed}
--   </pre>
--   
--   Note that the <a>MonadCatch</a> instance for <a>Proxy</a> provides
--   weaker versions of <a>mask</a> and <a>uninterruptibleMask</a> that do
--   not completely prevent asynchronous exceptions. Instead, they provide
--   a weaker guarantee that asynchronous exceptions will only occur during
--   <a>await</a>s or <a>yield</a>s and nowhere else. For example, if you
--   write:
--   
--   <pre>
--   mask_ $ do
--       x &lt;- await
--       lift $ print x
--       lift $ print x
--   </pre>
--   
--   ... then you may receive an asynchronous exception during the
--   <a>await</a>, but you will not receive an asynchronous exception
--   during or in between the two <a>print</a> statements. This weaker
--   guarantee suffices to provide asynchronous exception safety.
module Pipes.Safe

-- | <a>SafeT</a> is a monad transformer that extends the base monad with
--   the ability to <a>register</a> and <a>release</a> finalizers.
--   
--   All unreleased finalizers are called at the end of the <a>SafeT</a>
--   block, even in the event of exceptions.
data SafeT m r

-- | Run the <a>SafeT</a> monad transformer, executing all unreleased
--   finalizers at the end of the computation
runSafeT :: (MonadMask m, MonadIO m) => SafeT m r -> m r

-- | Run <a>SafeT</a> in the base monad, executing all unreleased
--   finalizers at the end of the computation
--   
--   Use <a>runSafeP</a> to safely flush all unreleased finalizers and
--   ensure prompt finalization without exiting the <a>Proxy</a> monad.
runSafeP :: (MonadMask m, MonadIO m) => Effect (SafeT m) r -> Effect' m r

-- | Token used to <a>release</a> a previously <a>register</a>ed finalizer
data ReleaseKey

-- | <a>MonadSafe</a> lets you <a>register</a> and <a>release</a>
--   finalizers that execute in a <a>Base</a> monad
class (MonadCatch m, MonadMask m, MonadIO m, MonadIO (Base m)) => MonadSafe m where {
    
    -- | The monad used to run resource management actions, corresponding to
    --   the monad directly beneath <a>SafeT</a>
    type family Base (m :: * -> *) :: * -> *;
}

-- | Lift an action from the <a>Base</a> monad
liftBase :: MonadSafe m => Base m r -> m r

-- | <a>register</a> a finalizer, ensuring that the finalizer gets called
--   if the finalizer is not <a>release</a>d before the end of the
--   surrounding <a>SafeT</a> block.
register :: MonadSafe m => Base m () -> m ReleaseKey

-- | <a>release</a> a registered finalizer
--   
--   You can safely call <a>release</a> more than once on the same
--   <a>ReleaseKey</a>. Every <a>release</a> after the first one does
--   nothing.
release :: MonadSafe m => ReleaseKey -> m ()

-- | Analogous to <a>onException</a> from <tt>Control.Monad.Catch</tt>,
--   except this also protects against premature termination
--   
--   <tt>(`onException` io)</tt> is a monad morphism.
onException :: MonadSafe m => m a -> Base m b -> m a

-- | Transform a <a>Proxy</a> into one that catches any exceptions caused
--   by its effects, and returns the resulting exception.
tryP :: (MonadSafe m, Exception e) => Proxy a' a b' b m r -> Proxy a' a b' b m (Either e r)

-- | Allows direct handling of exceptions raised by the effects in a
--   <a>Proxy</a>.
catchP :: (MonadSafe m, Exception e) => Proxy a' a b' b m r -> (e -> Proxy a' a b' b m r) -> Proxy a' a b' b m r

-- | Analogous to <a>finally</a> from <tt>Control.Monad.Catch</tt>, except
--   this also protects against premature termination
finally :: MonadSafe m => m a -> Base m b -> m a

-- | Analogous to <a>bracket</a> from <tt>Control.Monad.Catch</tt>, except
--   this also protects against premature termination
bracket :: MonadSafe m => Base m a -> (a -> Base m b) -> (a -> m c) -> m c

-- | Analogous to <a>bracket_</a> from <tt>Control.Monad.Catch</tt>, except
--   this also protects against premature termination
bracket_ :: MonadSafe m => Base m a -> Base m b -> m c -> m c

-- | Analogous to <a>bracketOnError</a> from <tt>Control.Monad.Catch</tt>,
--   except this also protects against premature termination
bracketOnError :: MonadSafe m => Base m a -> (a -> Base m b) -> (a -> m c) -> m c

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException

-- | Catches different sorts of exceptions. See <a>Control.Exception</a>'s
--   <a>catches</a>
catches :: (Foldable f, MonadCatch m) => m a -> f (Handler m a) -> m a

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught. See <a>Control.Exception</a>'s
--   <a>tryJust</a>
tryJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)

-- | Flipped <a>catchJust</a>. See <a>Control.Exception</a>'s
--   <a>handleJust</a>.
handleJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a

-- | Flipped <a>catchIf</a>
handleIf :: (MonadCatch m, Exception e) => (e -> Bool) -> (e -> m a) -> m a -> m a

-- | Flipped <a>catchAll</a>
handleAll :: MonadCatch m => (SomeException -> m a) -> m a -> m a

-- | Flipped <a>catchIOError</a>
handleIOError :: MonadCatch m => (IOError -> m a) -> m a -> m a

-- | Flipped <a>catch</a>. See <a>Control.Exception</a>'s <a>handle</a>.
handle :: (MonadCatch m, Exception e) => (e -> m a) -> m a -> m a

-- | A more generalized way of determining which exceptions to catch at run
--   time.
catchJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a

-- | Catch exceptions only if they pass some predicate. Often useful with
--   the predicates for testing <a>IOError</a> values in
--   <a>System.IO.Error</a>.
catchIf :: (MonadCatch m, Exception e) => (e -> Bool) -> m a -> (e -> m a) -> m a

-- | Catch all <a>IOError</a> (eqv. <tt>IOException</tt>) exceptions. Still
--   somewhat too general, but better than using <a>catchAll</a>. See
--   <a>catchIf</a> for an easy way of catching specific <a>IOError</a>s
--   based on the predicates in <a>System.IO.Error</a>.
catchIOError :: MonadCatch m => m a -> (IOError -> m a) -> m a

-- | Catches all exceptions, and somewhat defeats the purpose of the
--   extensible exception system. Use sparingly.
--   
--   <i>NOTE</i> This catches all <i>exceptions</i>, but if the monad
--   supports other ways of aborting the computation, those other kinds of
--   errors will not be caught.
catchAll :: MonadCatch m => m a -> (SomeException -> m a) -> m a

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: MonadMask m => m a -> m a

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: MonadMask m => m a -> m a

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: Type -> Type)

-- | Throw an exception. Note that this throws when this action is run in
--   the monad <tt>m</tt>, not when it is applied. It is a generalization
--   of <a>Control.Exception</a>'s <a>throwIO</a>.
--   
--   Should satisfy the law:
--   
--   <pre>
--   throwM e &gt;&gt; f = throwM e
--   </pre>
throwM :: (MonadThrow m, Exception e) => e -> m a

-- | A class for monads which allow exceptions to be caught, in particular
--   exceptions which were thrown by <a>throwM</a>.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   catch (throwM e) f = f e
--   </pre>
--   
--   Note that the ability to catch an exception does <i>not</i> guarantee
--   that we can deal with all possible exit points from a computation.
--   Some monads, such as continuation-based stacks, allow for more than
--   just a success/failure strategy, and therefore <tt>catch</tt>
--   <i>cannot</i> be used by those monads to properly implement a function
--   such as <tt>finally</tt>. For more information, see <a>MonadMask</a>.
class MonadThrow m => MonadCatch (m :: Type -> Type)

-- | Provide a handler for exceptions thrown during execution of the first
--   action. Note that type of the type of the argument to the handler will
--   constrain which exceptions are caught. See <a>Control.Exception</a>'s
--   <a>catch</a>.
catch :: (MonadCatch m, Exception e) => m a -> (e -> m a) -> m a

-- | A class for monads which provide for the ability to account for all
--   possible exit points from a computation, and to mask asynchronous
--   exceptions. Continuation-based monads are invalid instances of this
--   class.
--   
--   Instances should ensure that, in the following code:
--   
--   <pre>
--   fg = f `finally` g
--   </pre>
--   
--   The action <tt>g</tt> is called regardless of what occurs within
--   <tt>f</tt>, including async exceptions. Some monads allow <tt>f</tt>
--   to abort the computation via other effects than throwing an exception.
--   For simplicity, we will consider aborting and throwing an exception to
--   be two forms of "throwing an error".
--   
--   If <tt>f</tt> and <tt>g</tt> both throw an error, the error thrown by
--   <tt>fg</tt> depends on which errors we're talking about. In a monad
--   transformer stack, the deeper layers override the effects of the inner
--   layers; for example, <tt>ExceptT e1 (Except e2) a</tt> represents a
--   value of type <tt>Either e2 (Either e1 a)</tt>, so throwing both an
--   <tt>e1</tt> and an <tt>e2</tt> will result in <tt>Left e2</tt>. If
--   <tt>f</tt> and <tt>g</tt> both throw an error from the same layer,
--   instances should ensure that the error from <tt>g</tt> wins.
--   
--   Effects other than throwing an error are also overriden by the deeper
--   layers. For example, <tt>StateT s Maybe a</tt> represents a value of
--   type <tt>s -&gt; Maybe (a, s)</tt>, so if an error thrown from
--   <tt>f</tt> causes this function to return <tt>Nothing</tt>, any
--   changes to the state which <tt>f</tt> also performed will be erased.
--   As a result, <tt>g</tt> will see the state as it was before
--   <tt>f</tt>. Once <tt>g</tt> completes, <tt>f</tt>'s error will be
--   rethrown, so <tt>g</tt>' state changes will be erased as well. This is
--   the normal interaction between effects in a monad transformer stack.
--   
--   By contrast, <a>lifted-base</a>'s version of <a>finally</a> always
--   discards all of <tt>g</tt>'s non-IO effects, and <tt>g</tt> never sees
--   any of <tt>f</tt>'s non-IO effects, regardless of the layer ordering
--   and regardless of whether <tt>f</tt> throws an error. This is not the
--   result of interacting effects, but a consequence of
--   <tt>MonadBaseControl</tt>'s approach.
class MonadCatch m => MonadMask (m :: Type -> Type)

-- | Runs an action with asynchronous exceptions disabled. The action is
--   provided a method for restoring the async. environment to what it was
--   at the <a>mask</a> call. See <a>Control.Exception</a>'s <a>mask</a>.
mask :: MonadMask m => ((forall a. () => m a -> m a) -> m b) -> m b

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception</a>'s <a>uninterruptibleMask</a>. WARNING: Only
--   use if you need to mask exceptions around an interruptible operation
--   AND you can guarantee the interruptible operation will only block for
--   a short period of time. Otherwise you render the program/thread
--   unresponsive and/or unkillable.
uninterruptibleMask :: MonadMask m => ((forall a. () => m a -> m a) -> m b) -> m b

-- | A generalized version of <a>bracket</a> which uses <a>ExitCase</a> to
--   distinguish the different exit cases, and returns the values of both
--   the <tt>use</tt> and <tt>release</tt> actions. In practice, this extra
--   information is rarely needed, so it is often more convenient to use
--   one of the simpler functions which are defined in terms of this one,
--   such as <a>bracket</a>, <a>finally</a>, <a>onError</a>, and
--   <a>bracketOnError</a>.
--   
--   This function exists because in order to thread their effects through
--   the execution of <a>bracket</a>, monad transformers need values to be
--   threaded from <tt>use</tt> to <tt>release</tt> and from
--   <tt>release</tt> to the output value.
--   
--   <i>NOTE</i> This method was added in version 0.9.0 of this library.
--   Previously, implementation of functions like <a>bracket</a> and
--   <a>finally</a> in this module were based on the <a>mask</a> and
--   <a>uninterruptibleMask</a> functions only, disallowing some classes of
--   tranformers from having <tt>MonadMask</tt> instances (notably
--   multi-exit-point transformers like <a>ExceptT</a>). If you are a
--   library author, you'll now need to provide an implementation for this
--   method. The <tt>StateT</tt> implementation demonstrates most of the
--   subtleties:
--   
--   <pre>
--   generalBracket acquire release use = StateT $ s0 -&gt; do
--     ((b, _s2), (c, s3)) &lt;- generalBracket
--       (runStateT acquire s0)
--       ((resource, s1) exitCase -&gt; case exitCase of
--         ExitCaseSuccess (b, s2) -&gt; runStateT (release resource (ExitCaseSuccess b)) s2
--   
--         -- In the two other cases, the base monad overrides <tt>use</tt>'s state
--         -- changes and the state reverts to <tt>s1</tt>.
--         ExitCaseException e     -&gt; runStateT (release resource (ExitCaseException e)) s1
--         ExitCaseAbort           -&gt; runStateT (release resource ExitCaseAbort) s1
--       )
--       ((resource, s1) -&gt; runStateT (use resource) s1)
--     return ((b, c), s3)
--   </pre>
--   
--   The <tt>StateT s m</tt> implementation of <tt>generalBracket</tt>
--   delegates to the <tt>m</tt> implementation of <tt>generalBracket</tt>.
--   The <tt>acquire</tt>, <tt>use</tt>, and <tt>release</tt> arguments
--   given to <tt>StateT</tt>'s implementation produce actions of type
--   <tt>StateT s m a</tt>, <tt>StateT s m b</tt>, and <tt>StateT s m
--   c</tt>. In order to run those actions in the base monad, we need to
--   call <tt>runStateT</tt>, from which we obtain actions of type <tt>m
--   (a, s)</tt>, <tt>m (b, s)</tt>, and <tt>m (c, s)</tt>. Since each
--   action produces the next state, it is important to feed the state
--   produced by the previous action to the next action.
--   
--   In the <a>ExitCaseSuccess</a> case, the state starts at <tt>s0</tt>,
--   flows through <tt>acquire</tt> to become <tt>s1</tt>, flows through
--   <tt>use</tt> to become <tt>s2</tt>, and finally flows through
--   <tt>release</tt> to become <tt>s3</tt>. In the other two cases,
--   <tt>release</tt> does not receive the value <tt>s2</tt>, so its action
--   cannot see the state changes performed by <tt>use</tt>. This is fine,
--   because in those two cases, an error was thrown in the base monad, so
--   as per the usual interaction between effects in a monad transformer
--   stack, those state changes get reverted. So we start from <tt>s1</tt>
--   instead.
--   
--   Finally, the <tt>m</tt> implementation of <tt>generalBracket</tt>
--   returns the pairs <tt>(b, s)</tt> and <tt>(c, s)</tt>. For monad
--   transformers other than <tt>StateT</tt>, this will be some other type
--   representing the effects and values performed and returned by the
--   <tt>use</tt> and <tt>release</tt> actions. The effect part of the
--   <tt>use</tt> result, in this case <tt>_s2</tt>, usually needs to be
--   discarded, since those effects have already been incorporated in the
--   <tt>release</tt> action.
--   
--   The only effect which is intentionally not incorporated in the
--   <tt>release</tt> action is the effect of throwing an error. In that
--   case, the error must be re-thrown. One subtlety which is easy to miss
--   is that in the case in which <tt>use</tt> and <tt>release</tt> both
--   throw an error, the error from <tt>release</tt> should take priority.
--   Here is an implementation for <tt>ExceptT</tt> which demonstrates how
--   to do this.
--   
--   <pre>
--   generalBracket acquire release use = ExceptT $ do
--     (eb, ec) &lt;- generalBracket
--       (runExceptT acquire)
--       (eresource exitCase -&gt; case eresource of
--         Left e -&gt; return (Left e) -- nothing to release, acquire didn't succeed
--         Right resource -&gt; case exitCase of
--           ExitCaseSuccess (Right b) -&gt; runExceptT (release resource (ExitCaseSuccess b))
--           ExitCaseException e       -&gt; runExceptT (release resource (ExitCaseException e))
--           _                         -&gt; runExceptT (release resource ExitCaseAbort))
--       (either (return . Left) (runExceptT . use))
--     return $ do
--       -- The order in which we perform those two <a>Either</a> effects determines
--       -- which error will win if they are both <a>Left</a>s. We want the error from
--       -- <tt>release</tt> to win.
--       c &lt;- ec
--       b &lt;- eb
--       return (b, c)
--   </pre>
generalBracket :: MonadMask m => m a -> (a -> ExitCase b -> m c) -> (a -> m b) -> m (b, c)

-- | A <a>MonadMask</a> computation may either succeed with a value, abort
--   with an exception, or abort for some other reason. For example, in
--   <tt>ExceptT e IO</tt> you can use <a>throwM</a> to abort with an
--   exception (<a>ExitCaseException</a>) or <a>throwE</a> to abort with a
--   value of type <tt>e</tt> (<a>ExitCaseAbort</a>).
data ExitCase a
ExitCaseSuccess :: a -> ExitCase a
ExitCaseException :: SomeException -> ExitCase a
ExitCaseAbort :: ExitCase a

-- | Generalized version of <a>Handler</a>
data Handler (m :: Type -> Type) a
Handler :: (e -> m a) -> Handler (m :: Type -> Type) a

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Pipes.Safe.SafeT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Pipes.Safe.SafeT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Pipes.Safe.SafeT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Pipes.Safe.SafeT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Pipes.Safe.SafeT m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (Pipes.Safe.SafeT m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Pipes.Safe.SafeT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Pipes.Safe.SafeT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Pipes.Safe.SafeT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Pipes.Safe.SafeT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Pipes.Safe.SafeT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Pipes.Safe.SafeT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Pipes.Safe.SafeT m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Pipes.Safe.SafeT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Pipes.Safe.SafeT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Pipes.Safe.SafeT m)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Catch.MonadCatch m, Control.Monad.Catch.MonadMask m) => Pipes.Safe.MonadSafe (Pipes.Safe.SafeT m)
instance Pipes.Safe.MonadSafe m => Pipes.Safe.MonadSafe (Pipes.Internal.Proxy a' a b' b m)
instance Pipes.Safe.MonadSafe m => Pipes.Safe.MonadSafe (Control.Monad.Trans.Identity.IdentityT m)
instance Pipes.Safe.MonadSafe m => Pipes.Safe.MonadSafe (Control.Monad.Catch.Pure.CatchT m)
instance Pipes.Safe.MonadSafe m => Pipes.Safe.MonadSafe (Control.Monad.Trans.Reader.ReaderT i m)
instance Pipes.Safe.MonadSafe m => Pipes.Safe.MonadSafe (Control.Monad.Trans.State.Lazy.StateT s m)
instance Pipes.Safe.MonadSafe m => Pipes.Safe.MonadSafe (Control.Monad.Trans.State.Strict.StateT s m)
instance (Pipes.Safe.MonadSafe m, GHC.Base.Monoid w) => Pipes.Safe.MonadSafe (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Pipes.Safe.MonadSafe m, GHC.Base.Monoid w) => Pipes.Safe.MonadSafe (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Pipes.Safe.MonadSafe m, GHC.Base.Monoid w) => Pipes.Safe.MonadSafe (Control.Monad.Trans.RWS.Lazy.RWST i w s m)
instance (Pipes.Safe.MonadSafe m, GHC.Base.Monoid w) => Pipes.Safe.MonadSafe (Control.Monad.Trans.RWS.Strict.RWST i w s m)
instance Control.Monad.Trans.Class.MonadTrans Pipes.Safe.SafeT
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Pipes.Safe.SafeT m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Pipes.Safe.SafeT m)
instance (Control.Monad.Catch.MonadMask m, Control.Monad.IO.Class.MonadIO m) => Control.Monad.Catch.MonadMask (Pipes.Internal.Proxy a' a b' b m)


-- | Simple resource management functions
module Pipes.Safe.Prelude

-- | Acquire a <a>Handle</a> within <a>MonadSafe</a>
withFile :: MonadSafe m => FilePath -> IOMode -> (Handle -> m r) -> m r

-- | Read lines from a file, automatically opening and closing the file as
--   necessary
readFile :: MonadSafe m => FilePath -> Producer' String m ()

-- | Write lines to a file, automatically opening and closing the file as
--   necessary
writeFile :: MonadSafe m => FilePath -> Consumer' String m r
