-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/DCMLab/haskell-musicology#readme</a>
@package musicology-extra
@version 0.1.0.0

module Musicology.IO.CSV
fn :: [Char]
type CsvTrack = (:->) "Track" Bool
type CsvChannel = (:->) "Channel" Int
type CsvOnset = (:->) "Onset" Int
type CsvOffset = (:->) "Offset" Int
type CsvPitch = (:->) "Pitch" Int
type CsvVelocity = (:->) "Velocity" Int
type CsvNote = Record '[CsvTrack, CsvChannel, CsvOnset, CsvOffset, CsvPitch, CsvVelocity]
csvVelocity' :: forall f_ad6Q g_ad6R rs_ad6S. (Functor f_ad6Q, RElem CsvVelocity rs_ad6S (RIndex CsvVelocity rs_ad6S)) => (g_ad6R CsvVelocity -> f_ad6Q (g_ad6R CsvVelocity)) -> Rec g_ad6R rs_ad6S -> f_ad6Q (Rec g_ad6R rs_ad6S)
csvVelocity :: forall f_ad6O rs_ad6P. (Functor f_ad6O, RElem CsvVelocity rs_ad6P (RIndex CsvVelocity rs_ad6P)) => (Int -> f_ad6O Int) -> Record rs_ad6P -> f_ad6O (Record rs_ad6P)
csvPitch' :: forall f_ad6L g_ad6M rs_ad6N. (Functor f_ad6L, RElem CsvPitch rs_ad6N (RIndex CsvPitch rs_ad6N)) => (g_ad6M CsvPitch -> f_ad6L (g_ad6M CsvPitch)) -> Rec g_ad6M rs_ad6N -> f_ad6L (Rec g_ad6M rs_ad6N)
csvPitch :: forall f_ad6J rs_ad6K. (Functor f_ad6J, RElem CsvPitch rs_ad6K (RIndex CsvPitch rs_ad6K)) => (Int -> f_ad6J Int) -> Record rs_ad6K -> f_ad6J (Record rs_ad6K)
csvOffset' :: forall f_ad6G g_ad6H rs_ad6I. (Functor f_ad6G, RElem CsvOffset rs_ad6I (RIndex CsvOffset rs_ad6I)) => (g_ad6H CsvOffset -> f_ad6G (g_ad6H CsvOffset)) -> Rec g_ad6H rs_ad6I -> f_ad6G (Rec g_ad6H rs_ad6I)
csvOffset :: forall f_ad6E rs_ad6F. (Functor f_ad6E, RElem CsvOffset rs_ad6F (RIndex CsvOffset rs_ad6F)) => (Int -> f_ad6E Int) -> Record rs_ad6F -> f_ad6E (Record rs_ad6F)
csvOnset' :: forall f_ad6B g_ad6C rs_ad6D. (Functor f_ad6B, RElem CsvOnset rs_ad6D (RIndex CsvOnset rs_ad6D)) => (g_ad6C CsvOnset -> f_ad6B (g_ad6C CsvOnset)) -> Rec g_ad6C rs_ad6D -> f_ad6B (Rec g_ad6C rs_ad6D)
csvOnset :: forall f_ad6z rs_ad6A. (Functor f_ad6z, RElem CsvOnset rs_ad6A (RIndex CsvOnset rs_ad6A)) => (Int -> f_ad6z Int) -> Record rs_ad6A -> f_ad6z (Record rs_ad6A)
csvChannel' :: forall f_ad6w g_ad6x rs_ad6y. (Functor f_ad6w, RElem CsvChannel rs_ad6y (RIndex CsvChannel rs_ad6y)) => (g_ad6x CsvChannel -> f_ad6w (g_ad6x CsvChannel)) -> Rec g_ad6x rs_ad6y -> f_ad6w (Rec g_ad6x rs_ad6y)
csvChannel :: forall f_ad6u rs_ad6v. (Functor f_ad6u, RElem CsvChannel rs_ad6v (RIndex CsvChannel rs_ad6v)) => (Int -> f_ad6u Int) -> Record rs_ad6v -> f_ad6u (Record rs_ad6v)
csvTrack' :: forall f_ad6r g_ad6s rs_ad6t. (Functor f_ad6r, RElem CsvTrack rs_ad6t (RIndex CsvTrack rs_ad6t)) => (g_ad6s CsvTrack -> f_ad6r (g_ad6s CsvTrack)) -> Rec g_ad6s rs_ad6t -> f_ad6r (Rec g_ad6s rs_ad6t)
csvTrack :: forall f_ad6p rs_ad6q. (Functor f_ad6p, RElem CsvTrack rs_ad6q (RIndex CsvTrack rs_ad6q)) => (Bool -> f_ad6p Bool) -> Record rs_ad6q -> f_ad6p (Record rs_ad6q)
csvNoteParser :: ParserOptions
loadPiece :: FilePath -> IO (Frame CsvNote)
frameNotes :: Frame CsvNote -> [Note MidiInterval Int]

module Musicology.Internal.GatedQueue
type GatedQueue k v = Map k v

-- | <i>O(log n)</i>. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Ord k => k -> a -> Map k a -> Map k a

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
release :: Ord k => GatedQueue k v -> k -> (GatedQueue k v, [v])

-- | <i>O(1)</i>. Is the map empty?
--   
--   <pre>
--   Data.Map.null (empty)           == True
--   Data.Map.null (singleton 1 'a') == False
--   </pre>
null :: Map k a -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression (<tt><a>union</a>
--   t1 t2</tt>) takes the left-biased union of <tt>t1</tt> and
--   <tt>t2</tt>. It prefers <tt>t1</tt> when duplicate keys are
--   encountered, i.e. (<tt><a>union</a> == <a>unionWith</a>
--   <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Ord k => Map k a -> Map k a -> Map k a

module Musicology.Internal.Helpers
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
processFoldable :: Foldable t => t a -> MachineT Identity (Is a) b -> [b]
processFoldableT :: (Monad m, Foldable t) => t a -> ProcessT m a b -> m [b]
showRow :: (RecMapMethod Show ElField a, RecordToList a) => Record a -> String
showHeader :: forall a. ColumnHeaders a => Frame (Record a) -> String
previewFrame :: (RecMapMethod Show ElField a, RecordToList a, ColumnHeaders a) => Int -> Frame (Record a) -> IO ()
viewFrame :: (RecMapMethod Show ElField a, RecordToList a, ColumnHeaders a) => Frame (Record a) -> IO ()
mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
release :: Ord k => Map k v -> k -> (Map k v, [v])
intFills :: (Eq p, Interval p) => p -> p -> Bool
rerunStateT :: (m (a, s) -> n (b, t)) -> (t -> s) -> StateT s m a -> StateT t n b

module Musicology.IO.MidiFile
data MidiNote
MidiNote :: Int -> Int -> Ratio Int -> Ratio Int -> Double -> Double -> MidiPitch -> Int -> Int -> Int -> Int -> Bool -> Int -> Int -> Ratio Int -> MidiNote
[_onsetTicks] :: MidiNote -> Int
[_offsetTicks] :: MidiNote -> Int
[_onsetWholes] :: MidiNote -> Ratio Int
[_offsetWholes] :: MidiNote -> Ratio Int
[_onsetSecs] :: MidiNote -> Double
[_offsetSecs] :: MidiNote -> Double
[_pitch] :: MidiNote -> MidiPitch
[_velocity] :: MidiNote -> Int
[_trackNum] :: MidiNote -> Int
[_channel] :: MidiNote -> Int
[_keySharps] :: MidiNote -> Int
[_keyMajor] :: MidiNote -> Bool
[_bar] :: MidiNote -> Int
[_beat] :: MidiNote -> Int
[_subbeat] :: MidiNote -> Ratio Int
asTicks :: MidiNote -> Note MidiInterval Int
asWholes :: MidiNote -> Note MidiInterval (Ratio Int)
asSecs :: MidiNote -> Note MidiInterval Double
type MidiRecord = Record '["onsetTicks" :-> Int, "offsetTicks" :-> Int, "onsetWholes" :-> Ratio Int, "offsetWholes" :-> Ratio Int, "onsetSecs" :-> Double, "offsetSecs" :-> Double, "pitch" :-> Int, "velocity" :-> Int, "trackNum" :-> Int, "channel" :-> Int, "keySharps" :-> Int, "keyMajor" :-> Bool, "bar" :-> Int, "beat" :-> Int, "subbeat" :-> Ratio Int]
type RatioInt = Ratio Int
type OnsetTicks = (:->) "onsetTicks" Int
onsetTicks' :: forall f_ai6Z g_ai70 rs_ai71. (Functor f_ai6Z, RElem OnsetTicks rs_ai71 (RIndex OnsetTicks rs_ai71)) => (g_ai70 OnsetTicks -> f_ai6Z (g_ai70 OnsetTicks)) -> Rec g_ai70 rs_ai71 -> f_ai6Z (Rec g_ai70 rs_ai71)
onsetTicks :: forall f_ai6X rs_ai6Y. (Functor f_ai6X, RElem OnsetTicks rs_ai6Y (RIndex OnsetTicks rs_ai6Y)) => (Int -> f_ai6X Int) -> Record rs_ai6Y -> f_ai6X (Record rs_ai6Y)
type OffsetTicks = (:->) "offsetTicks" Int
offsetTicks' :: forall f_ai9h g_ai9i rs_ai9j. (Functor f_ai9h, RElem OffsetTicks rs_ai9j (RIndex OffsetTicks rs_ai9j)) => (g_ai9i OffsetTicks -> f_ai9h (g_ai9i OffsetTicks)) -> Rec g_ai9i rs_ai9j -> f_ai9h (Rec g_ai9i rs_ai9j)
offsetTicks :: forall f_ai9f rs_ai9g. (Functor f_ai9f, RElem OffsetTicks rs_ai9g (RIndex OffsetTicks rs_ai9g)) => (Int -> f_ai9f Int) -> Record rs_ai9g -> f_ai9f (Record rs_ai9g)
type OnsetWholes = (:->) "onsetWholes" RatioInt
onsetWholes' :: forall f_aibz g_aibA rs_aibB. (Functor f_aibz, RElem OnsetWholes rs_aibB (RIndex OnsetWholes rs_aibB)) => (g_aibA OnsetWholes -> f_aibz (g_aibA OnsetWholes)) -> Rec g_aibA rs_aibB -> f_aibz (Rec g_aibA rs_aibB)
onsetWholes :: forall f_aibx rs_aiby. (Functor f_aibx, RElem OnsetWholes rs_aiby (RIndex OnsetWholes rs_aiby)) => (RatioInt -> f_aibx RatioInt) -> Record rs_aiby -> f_aibx (Record rs_aiby)
type OffsetWholes = (:->) "offsetWholes" RatioInt
offsetWholes' :: forall f_aidR g_aidS rs_aidT. (Functor f_aidR, RElem OffsetWholes rs_aidT (RIndex OffsetWholes rs_aidT)) => (g_aidS OffsetWholes -> f_aidR (g_aidS OffsetWholes)) -> Rec g_aidS rs_aidT -> f_aidR (Rec g_aidS rs_aidT)
offsetWholes :: forall f_aidP rs_aidQ. (Functor f_aidP, RElem OffsetWholes rs_aidQ (RIndex OffsetWholes rs_aidQ)) => (RatioInt -> f_aidP RatioInt) -> Record rs_aidQ -> f_aidP (Record rs_aidQ)
type OnsetSecs = (:->) "onsetSecs" Int
onsetSecs' :: forall f_aig9 g_aiga rs_aigb. (Functor f_aig9, RElem OnsetSecs rs_aigb (RIndex OnsetSecs rs_aigb)) => (g_aiga OnsetSecs -> f_aig9 (g_aiga OnsetSecs)) -> Rec g_aiga rs_aigb -> f_aig9 (Rec g_aiga rs_aigb)
onsetSecs :: forall f_aig7 rs_aig8. (Functor f_aig7, RElem OnsetSecs rs_aig8 (RIndex OnsetSecs rs_aig8)) => (Int -> f_aig7 Int) -> Record rs_aig8 -> f_aig7 (Record rs_aig8)
type OffsetSecs = (:->) "offsetSecs" Int
offsetSecs' :: forall f_aiir g_aiis rs_aiit. (Functor f_aiir, RElem OffsetSecs rs_aiit (RIndex OffsetSecs rs_aiit)) => (g_aiis OffsetSecs -> f_aiir (g_aiis OffsetSecs)) -> Rec g_aiis rs_aiit -> f_aiir (Rec g_aiis rs_aiit)
offsetSecs :: forall f_aiip rs_aiiq. (Functor f_aiip, RElem OffsetSecs rs_aiiq (RIndex OffsetSecs rs_aiiq)) => (Int -> f_aiip Int) -> Record rs_aiiq -> f_aiip (Record rs_aiiq)
type Pitch = (:->) "pitch" Int
pitch' :: forall f_aikJ g_aikK rs_aikL. (Functor f_aikJ, RElem Pitch rs_aikL (RIndex Pitch rs_aikL)) => (g_aikK Pitch -> f_aikJ (g_aikK Pitch)) -> Rec g_aikK rs_aikL -> f_aikJ (Rec g_aikK rs_aikL)
pitch :: forall f_aikH rs_aikI. (Functor f_aikH, RElem Pitch rs_aikI (RIndex Pitch rs_aikI)) => (Int -> f_aikH Int) -> Record rs_aikI -> f_aikH (Record rs_aikI)
type Velocity = (:->) "velocity" Int
velocity' :: forall f_ain1 g_ain2 rs_ain3. (Functor f_ain1, RElem Velocity rs_ain3 (RIndex Velocity rs_ain3)) => (g_ain2 Velocity -> f_ain1 (g_ain2 Velocity)) -> Rec g_ain2 rs_ain3 -> f_ain1 (Rec g_ain2 rs_ain3)
velocity :: forall f_aimZ rs_ain0. (Functor f_aimZ, RElem Velocity rs_ain0 (RIndex Velocity rs_ain0)) => (Int -> f_aimZ Int) -> Record rs_ain0 -> f_aimZ (Record rs_ain0)
type TrackNum = (:->) "trackNum" Int
trackNum' :: forall f_aipj g_aipk rs_aipl. (Functor f_aipj, RElem TrackNum rs_aipl (RIndex TrackNum rs_aipl)) => (g_aipk TrackNum -> f_aipj (g_aipk TrackNum)) -> Rec g_aipk rs_aipl -> f_aipj (Rec g_aipk rs_aipl)
trackNum :: forall f_aiph rs_aipi. (Functor f_aiph, RElem TrackNum rs_aipi (RIndex TrackNum rs_aipi)) => (Int -> f_aiph Int) -> Record rs_aipi -> f_aiph (Record rs_aipi)
type Channel = (:->) "channel" Int
channel' :: forall f_airB g_airC rs_airD. (Functor f_airB, RElem Channel rs_airD (RIndex Channel rs_airD)) => (g_airC Channel -> f_airB (g_airC Channel)) -> Rec g_airC rs_airD -> f_airB (Rec g_airC rs_airD)
channel :: forall f_airz rs_airA. (Functor f_airz, RElem Channel rs_airA (RIndex Channel rs_airA)) => (Int -> f_airz Int) -> Record rs_airA -> f_airz (Record rs_airA)
type KeySharps = (:->) "keySharps" Int
keySharps' :: forall f_aitT g_aitU rs_aitV. (Functor f_aitT, RElem KeySharps rs_aitV (RIndex KeySharps rs_aitV)) => (g_aitU KeySharps -> f_aitT (g_aitU KeySharps)) -> Rec g_aitU rs_aitV -> f_aitT (Rec g_aitU rs_aitV)
keySharps :: forall f_aitR rs_aitS. (Functor f_aitR, RElem KeySharps rs_aitS (RIndex KeySharps rs_aitS)) => (Int -> f_aitR Int) -> Record rs_aitS -> f_aitR (Record rs_aitS)
type KeyMajor = (:->) "keyMajor" Bool
keyMajor' :: forall f_aiwb g_aiwc rs_aiwd. (Functor f_aiwb, RElem KeyMajor rs_aiwd (RIndex KeyMajor rs_aiwd)) => (g_aiwc KeyMajor -> f_aiwb (g_aiwc KeyMajor)) -> Rec g_aiwc rs_aiwd -> f_aiwb (Rec g_aiwc rs_aiwd)
keyMajor :: forall f_aiw9 rs_aiwa. (Functor f_aiw9, RElem KeyMajor rs_aiwa (RIndex KeyMajor rs_aiwa)) => (Bool -> f_aiw9 Bool) -> Record rs_aiwa -> f_aiw9 (Record rs_aiwa)
type Bar = (:->) "bar" Int
bar' :: forall f_aiyt g_aiyu rs_aiyv. (Functor f_aiyt, RElem Bar rs_aiyv (RIndex Bar rs_aiyv)) => (g_aiyu Bar -> f_aiyt (g_aiyu Bar)) -> Rec g_aiyu rs_aiyv -> f_aiyt (Rec g_aiyu rs_aiyv)
bar :: forall f_aiyr rs_aiys. (Functor f_aiyr, RElem Bar rs_aiys (RIndex Bar rs_aiys)) => (Int -> f_aiyr Int) -> Record rs_aiys -> f_aiyr (Record rs_aiys)
type Beat = (:->) "beat" Int
beat' :: forall f_aiAL g_aiAM rs_aiAN. (Functor f_aiAL, RElem Beat rs_aiAN (RIndex Beat rs_aiAN)) => (g_aiAM Beat -> f_aiAL (g_aiAM Beat)) -> Rec g_aiAM rs_aiAN -> f_aiAL (Rec g_aiAM rs_aiAN)
beat :: forall f_aiAJ rs_aiAK. (Functor f_aiAJ, RElem Beat rs_aiAK (RIndex Beat rs_aiAK)) => (Int -> f_aiAJ Int) -> Record rs_aiAK -> f_aiAJ (Record rs_aiAK)
type Subbeat = (:->) "subbeat" RatioInt
subbeat' :: forall f_aiD3 g_aiD4 rs_aiD5. (Functor f_aiD3, RElem Subbeat rs_aiD5 (RIndex Subbeat rs_aiD5)) => (g_aiD4 Subbeat -> f_aiD3 (g_aiD4 Subbeat)) -> Rec g_aiD4 rs_aiD5 -> f_aiD3 (Rec g_aiD4 rs_aiD5)
subbeat :: forall f_aiD1 rs_aiD2. (Functor f_aiD1, RElem Subbeat rs_aiD2 (RIndex Subbeat rs_aiD2)) => (RatioInt -> f_aiD1 RatioInt) -> Record rs_aiD2 -> f_aiD1 (Record rs_aiD2)
midiNoteToRecord :: MidiNote -> MidiRecord
printNote :: MidiNote -> IO ()
type PrepEv a = (Int, Message, (a, Message))
prepareTrack :: Track a -> Int -> [PrepEv a]
mergeTracks :: Ord a => [PrepEv a] -> [PrepEv a] -> [PrepEv a]
midiEvents :: Midi -> [PrepEv Ticks]
timeRatios :: TimeDiv -> Int -> (Ratio Int, Double)
type Resolver a = [a] -> [a] -> [a]
queue :: Resolver a
stack :: Resolver a
data OnVal
OnVal :: Int -> Ratio Int -> Double -> Int -> Message -> Int -> Int -> Ratio Int -> OnVal
[ovNowT] :: OnVal -> Int
[ovNowW] :: OnVal -> Ratio Int
[ovNowS] :: OnVal -> Double
[ovVel] :: OnVal -> Int
[ovKeySig] :: OnVal -> Message
[ovBar] :: OnVal -> Int
[ovBeat] :: OnVal -> Int
[ovSubbeat] :: OnVal -> Ratio Int
type Ons = HashMap (Int, Int, Int) [OnVal]
type Coeffs a = (a, a)
data MidiState
MidiState :: Ons -> Coeffs (Ratio Int) -> Coeffs Double -> Ratio Int -> Int -> Ratio Int -> Ratio Int -> MidiState
[msOns] :: MidiState -> Ons
[msWCoeffs] :: MidiState -> Coeffs (Ratio Int)
[msSCoeffs] :: MidiState -> Coeffs Double
[msBarOff] :: MidiState -> Ratio Int
[msBarRef] :: MidiState -> Int
[msBarLen] :: MidiState -> Ratio Int
[msBeatLen] :: MidiState -> Ratio Int
eventsToNotes :: [PrepEv Ticks] -> TimeDiv -> Resolver OnVal -> [MidiNote]
notesToFrame :: [MidiNote] -> Frame MidiRecord
midiTracks :: FilePath -> IO [Track Ticks]
midiLoadEvs :: FilePath -> IO [PrepEv Ticks]
midiLoadNotes :: FilePath -> IO [MidiNote]
pieceBarlen :: FilePath -> IO (Ratio Int)
pieceBeatlen :: Integral a => FilePath -> IO (Ratio a)
dirMidiPieces :: FilePath -> IO [FilePath]
instance GHC.Generics.Generic Musicology.IO.MidiFile.MidiNote
instance GHC.Show.Show Musicology.IO.MidiFile.MidiNote
instance GHC.Classes.Eq Musicology.IO.MidiFile.MidiNote
instance Control.DeepSeq.NFData Musicology.IO.MidiFile.MidiNote

module Musicology.Grams
(.:) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
(.::) :: (b -> c) -> (a1 -> a2 -> a3 -> a4 -> b) -> a1 -> a2 -> a3 -> a4 -> c
gramsMach :: Int -> Process a [a]
grams :: Foldable t => Int -> t a -> [[a]]
skipgramsRMach :: (Num k, Ord k, Integral n, Monad m) => m Bool -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> ProcessT m a [a]
skipgramsRSMach :: (Num k, Ord k, Integral n, Monad m) => m Bool -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> ProcessT m a [a]
skipgramsMach :: (Num k, Ord k, Integral n) => ([a] -> Bool) -> (a -> a -> k) -> n -> k -> Process a [a]
skipgramsSMach :: (Num k, Ord k, Integral n) => ([a] -> Bool) -> (a -> a -> k) -> n -> k -> Process a [a]
skipgrams :: (Foldable t, Num k, Ord k, Integral n) => t a -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> [[a]]
skipgramsS :: (Foldable t, Num k, Ord k, Integral n) => t a -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> [[a]]
mkCoin :: (PrimMonad m, Integral n) => Double -> n -> Gen (PrimState m) -> m Bool
skipgramsR :: (Foldable t, Num k, Ord k, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> m [[a]]
skipgramsRS :: (Foldable t, Num k, Ord k, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> m [[a]]
enum :: (Num b, Enum b) => [a] -> [(a, b)]
indexCost :: Num a1 => (a2, a1) -> (a3, a1) -> a1
mune :: [[(b1, b2)]] -> [[b1]]
indexSkipgrams :: [a] -> Int -> Int -> [[a]]
indexSkipgramsR :: PrimMonad m => [a] -> Double -> Gen (PrimState m) -> Int -> Int -> m [[a]]
indexSkipgramsS :: [a] -> Int -> Int -> [[a]]
indexSkipgramsRS :: PrimMonad m => [a] -> Double -> Gen (PrimState m) -> Int -> Int -> m [[a]]

module Musicology.Polygrams
onsetdist :: HasTime a => a -> a -> TimeOf a
vonset :: HasTime a => [a] -> TimeOf a
voffset :: (Foldable t, Functor t, HasTime a) => t a -> TimeOf a
nooverlap :: HasTime a => [[a]] -> Bool
groupdist :: HasTime a => TimeOf a -> [a] -> [a] -> TimeOf a
verticals :: (HasTime a, Foldable t, Integral n) => t a -> n -> TimeOf a -> [[a]]
verticalsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> n -> TimeOf a -> m [[a]]
horizontals :: (HasTime a, Foldable t, Integral n) => t [a] -> n -> TimeOf a -> [[[a]]]
horizontalsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t [a] -> Double -> Gen (PrimState m) -> n -> TimeOf a -> m [[[a]]]
polygrams :: (HasTime a, Foldable t, Integral n) => t a -> n -> n -> TimeOf a -> [[[a]]]
polygramsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t a -> Double -> Double -> Gen (PrimState m) -> n -> n -> TimeOf a -> m [[[a]]]
verticalsMach :: (Integral n, Monad m, HasTime a) => m Bool -> n -> TimeOf a -> ProcessT m a [a]
horizontalsMach :: (Integral n, Monad m, HasTime a) => m Bool -> n -> TimeOf a -> ProcessT m [a] [[a]]
polygramsMachR :: (Monad m, HasTime a, Integral n1, Integral n2) => m Bool -> m Bool -> n1 -> n2 -> TimeOf a -> TimeOf a -> MachineT m (Is a) [[a]]
polygramsMach :: (HasTime a, Integral n) => n -> n -> TimeOf a -> TimeOf a -> Process a [[a]]
polygrams' :: (HasTime a, Foldable t, Integral n) => t a -> n -> n -> TimeOf a -> [[[a]]]
