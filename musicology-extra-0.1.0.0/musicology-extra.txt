-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/DCMLab/haskell-musicology#readme</a>
@package musicology-extra
@version 0.1.0.0

module Musicology.IO.CSV
fn :: String
type CsvTrack = (:->) "Track" Bool
type CsvChannel = (:->) "Channel" Int
type CsvOnset = (:->) "Onset" Int
type CsvOffset = (:->) "Offset" Int
type CsvPitch = (:->) "Pitch" Int
type CsvVelocity = (:->) "Velocity" Int
type CsvNote = Record '[CsvTrack, CsvChannel, CsvOnset, CsvOffset, CsvPitch, CsvVelocity]
csvVelocity' :: forall f_aeZn g_aeZo rs_aeZp. (Functor f_aeZn, RElem CsvVelocity rs_aeZp (RIndex CsvVelocity rs_aeZp)) => (g_aeZo CsvVelocity -> f_aeZn (g_aeZo CsvVelocity)) -> Rec g_aeZo rs_aeZp -> f_aeZn (Rec g_aeZo rs_aeZp)
csvVelocity :: forall f_aeZl rs_aeZm. (Functor f_aeZl, RElem CsvVelocity rs_aeZm (RIndex CsvVelocity rs_aeZm)) => (Int -> f_aeZl Int) -> Record rs_aeZm -> f_aeZl (Record rs_aeZm)
csvPitch' :: forall f_aeZi g_aeZj rs_aeZk. (Functor f_aeZi, RElem CsvPitch rs_aeZk (RIndex CsvPitch rs_aeZk)) => (g_aeZj CsvPitch -> f_aeZi (g_aeZj CsvPitch)) -> Rec g_aeZj rs_aeZk -> f_aeZi (Rec g_aeZj rs_aeZk)
csvPitch :: forall f_aeZg rs_aeZh. (Functor f_aeZg, RElem CsvPitch rs_aeZh (RIndex CsvPitch rs_aeZh)) => (Int -> f_aeZg Int) -> Record rs_aeZh -> f_aeZg (Record rs_aeZh)
csvOffset' :: forall f_aeZd g_aeZe rs_aeZf. (Functor f_aeZd, RElem CsvOffset rs_aeZf (RIndex CsvOffset rs_aeZf)) => (g_aeZe CsvOffset -> f_aeZd (g_aeZe CsvOffset)) -> Rec g_aeZe rs_aeZf -> f_aeZd (Rec g_aeZe rs_aeZf)
csvOffset :: forall f_aeZb rs_aeZc. (Functor f_aeZb, RElem CsvOffset rs_aeZc (RIndex CsvOffset rs_aeZc)) => (Int -> f_aeZb Int) -> Record rs_aeZc -> f_aeZb (Record rs_aeZc)
csvOnset' :: forall f_aeZ8 g_aeZ9 rs_aeZa. (Functor f_aeZ8, RElem CsvOnset rs_aeZa (RIndex CsvOnset rs_aeZa)) => (g_aeZ9 CsvOnset -> f_aeZ8 (g_aeZ9 CsvOnset)) -> Rec g_aeZ9 rs_aeZa -> f_aeZ8 (Rec g_aeZ9 rs_aeZa)
csvOnset :: forall f_aeZ6 rs_aeZ7. (Functor f_aeZ6, RElem CsvOnset rs_aeZ7 (RIndex CsvOnset rs_aeZ7)) => (Int -> f_aeZ6 Int) -> Record rs_aeZ7 -> f_aeZ6 (Record rs_aeZ7)
csvChannel' :: forall f_aeZ3 g_aeZ4 rs_aeZ5. (Functor f_aeZ3, RElem CsvChannel rs_aeZ5 (RIndex CsvChannel rs_aeZ5)) => (g_aeZ4 CsvChannel -> f_aeZ3 (g_aeZ4 CsvChannel)) -> Rec g_aeZ4 rs_aeZ5 -> f_aeZ3 (Rec g_aeZ4 rs_aeZ5)
csvChannel :: forall f_aeZ1 rs_aeZ2. (Functor f_aeZ1, RElem CsvChannel rs_aeZ2 (RIndex CsvChannel rs_aeZ2)) => (Int -> f_aeZ1 Int) -> Record rs_aeZ2 -> f_aeZ1 (Record rs_aeZ2)
csvTrack' :: forall f_aeYY g_aeYZ rs_aeZ0. (Functor f_aeYY, RElem CsvTrack rs_aeZ0 (RIndex CsvTrack rs_aeZ0)) => (g_aeYZ CsvTrack -> f_aeYY (g_aeYZ CsvTrack)) -> Rec g_aeYZ rs_aeZ0 -> f_aeYY (Rec g_aeYZ rs_aeZ0)
csvTrack :: forall f_aeYW rs_aeYX. (Functor f_aeYW, RElem CsvTrack rs_aeYX (RIndex CsvTrack rs_aeYX)) => (Bool -> f_aeYW Bool) -> Record rs_aeYX -> f_aeYW (Record rs_aeYX)
csvNoteParser :: ParserOptions
loadPiece :: FilePath -> IO (Frame CsvNote)
frameNotes :: Frame CsvNote -> [Note MidiInterval Int]

module Musicology.Internal.GatedQueue
type GatedQueue k v = Map k v

-- | &lt;math&gt;. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Ord k => k -> a -> Map k a -> Map k a

-- | &lt;math&gt;. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
release :: Ord k => GatedQueue k v -> k -> (GatedQueue k v, [v])

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Map.null (empty)           == True
--   Data.Map.null (singleton 1 'a') == False
--   </pre>
null :: Map k a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>union</a> t1 t2</tt>) takes the
--   left-biased union of <tt>t1</tt> and <tt>t2</tt>. It prefers
--   <tt>t1</tt> when duplicate keys are encountered, i.e.
--   (<tt><a>union</a> == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Ord k => Map k a -> Map k a -> Map k a

module Musicology.Internal.Helpers
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
processFoldable :: Foldable t => t a -> MachineT Identity (Is a) b -> [b]
processFoldableT :: (Monad m, Foldable t) => t a -> ProcessT m a b -> m [b]
showRow :: (RecMapMethod Show ElField a, RecordToList a) => Record a -> String
showHeader :: forall a. ColumnHeaders a => Frame (Record a) -> String
previewFrame :: (RecMapMethod Show ElField a, RecordToList a, ColumnHeaders a) => Int -> Frame (Record a) -> IO ()
viewFrame :: (RecMapMethod Show ElField a, RecordToList a, ColumnHeaders a) => Frame (Record a) -> IO ()
mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
release :: Ord k => Map k v -> k -> (Map k v, [v])
intFills :: (Eq p, Interval p) => p -> p -> Bool
rerunStateT :: (m (a, s) -> n (b, t)) -> (t -> s) -> StateT s m a -> StateT t n b

module Musicology.IO.MidiFile
data MidiNote
MidiNote :: Int -> Int -> Ratio Int -> Ratio Int -> Double -> Double -> MidiPitch -> Int -> Int -> Int -> Int -> Bool -> Int -> Int -> Ratio Int -> MidiNote
[_onsetTicks] :: MidiNote -> Int
[_offsetTicks] :: MidiNote -> Int
[_onsetWholes] :: MidiNote -> Ratio Int
[_offsetWholes] :: MidiNote -> Ratio Int
[_onsetSecs] :: MidiNote -> Double
[_offsetSecs] :: MidiNote -> Double
[_pitch] :: MidiNote -> MidiPitch
[_velocity] :: MidiNote -> Int
[_trackNum] :: MidiNote -> Int
[_channel] :: MidiNote -> Int
[_keySharps] :: MidiNote -> Int
[_keyMajor] :: MidiNote -> Bool
[_bar] :: MidiNote -> Int
[_beat] :: MidiNote -> Int
[_subbeat] :: MidiNote -> Ratio Int
asTicks :: MidiNote -> Note MidiInterval Int
asWholes :: MidiNote -> Note MidiInterval (Ratio Int)
asSecs :: MidiNote -> Note MidiInterval Double
type MidiRecord = Record '["onsetTicks" :-> Int, "offsetTicks" :-> Int, "onsetWholes" :-> Ratio Int, "offsetWholes" :-> Ratio Int, "onsetSecs" :-> Double, "offsetSecs" :-> Double, "pitch" :-> Int, "velocity" :-> Int, "trackNum" :-> Int, "channel" :-> Int, "keySharps" :-> Int, "keyMajor" :-> Bool, "bar" :-> Int, "beat" :-> Int, "subbeat" :-> Ratio Int]
type RatioInt = Ratio Int
type OnsetTicks = (:->) "onsetTicks" Int
onsetTicks' :: forall f_aiE9 g_aiEa rs_aiEb. (Functor f_aiE9, RElem OnsetTicks rs_aiEb (RIndex OnsetTicks rs_aiEb)) => (g_aiEa OnsetTicks -> f_aiE9 (g_aiEa OnsetTicks)) -> Rec g_aiEa rs_aiEb -> f_aiE9 (Rec g_aiEa rs_aiEb)
onsetTicks :: forall f_aiE7 rs_aiE8. (Functor f_aiE7, RElem OnsetTicks rs_aiE8 (RIndex OnsetTicks rs_aiE8)) => (Int -> f_aiE7 Int) -> Record rs_aiE8 -> f_aiE7 (Record rs_aiE8)
type OffsetTicks = (:->) "offsetTicks" Int
offsetTicks' :: forall f_aiGC g_aiGD rs_aiGE. (Functor f_aiGC, RElem OffsetTicks rs_aiGE (RIndex OffsetTicks rs_aiGE)) => (g_aiGD OffsetTicks -> f_aiGC (g_aiGD OffsetTicks)) -> Rec g_aiGD rs_aiGE -> f_aiGC (Rec g_aiGD rs_aiGE)
offsetTicks :: forall f_aiGA rs_aiGB. (Functor f_aiGA, RElem OffsetTicks rs_aiGB (RIndex OffsetTicks rs_aiGB)) => (Int -> f_aiGA Int) -> Record rs_aiGB -> f_aiGA (Record rs_aiGB)
type OnsetWholes = (:->) "onsetWholes" RatioInt
onsetWholes' :: forall f_aiJ5 g_aiJ6 rs_aiJ7. (Functor f_aiJ5, RElem OnsetWholes rs_aiJ7 (RIndex OnsetWholes rs_aiJ7)) => (g_aiJ6 OnsetWholes -> f_aiJ5 (g_aiJ6 OnsetWholes)) -> Rec g_aiJ6 rs_aiJ7 -> f_aiJ5 (Rec g_aiJ6 rs_aiJ7)
onsetWholes :: forall f_aiJ3 rs_aiJ4. (Functor f_aiJ3, RElem OnsetWholes rs_aiJ4 (RIndex OnsetWholes rs_aiJ4)) => (RatioInt -> f_aiJ3 RatioInt) -> Record rs_aiJ4 -> f_aiJ3 (Record rs_aiJ4)
type OffsetWholes = (:->) "offsetWholes" RatioInt
offsetWholes' :: forall f_aiLy g_aiLz rs_aiLA. (Functor f_aiLy, RElem OffsetWholes rs_aiLA (RIndex OffsetWholes rs_aiLA)) => (g_aiLz OffsetWholes -> f_aiLy (g_aiLz OffsetWholes)) -> Rec g_aiLz rs_aiLA -> f_aiLy (Rec g_aiLz rs_aiLA)
offsetWholes :: forall f_aiLw rs_aiLx. (Functor f_aiLw, RElem OffsetWholes rs_aiLx (RIndex OffsetWholes rs_aiLx)) => (RatioInt -> f_aiLw RatioInt) -> Record rs_aiLx -> f_aiLw (Record rs_aiLx)
type OnsetSecs = (:->) "onsetSecs" Int
onsetSecs' :: forall f_aiO1 g_aiO2 rs_aiO3. (Functor f_aiO1, RElem OnsetSecs rs_aiO3 (RIndex OnsetSecs rs_aiO3)) => (g_aiO2 OnsetSecs -> f_aiO1 (g_aiO2 OnsetSecs)) -> Rec g_aiO2 rs_aiO3 -> f_aiO1 (Rec g_aiO2 rs_aiO3)
onsetSecs :: forall f_aiNZ rs_aiO0. (Functor f_aiNZ, RElem OnsetSecs rs_aiO0 (RIndex OnsetSecs rs_aiO0)) => (Int -> f_aiNZ Int) -> Record rs_aiO0 -> f_aiNZ (Record rs_aiO0)
type OffsetSecs = (:->) "offsetSecs" Int
offsetSecs' :: forall f_aiQu g_aiQv rs_aiQw. (Functor f_aiQu, RElem OffsetSecs rs_aiQw (RIndex OffsetSecs rs_aiQw)) => (g_aiQv OffsetSecs -> f_aiQu (g_aiQv OffsetSecs)) -> Rec g_aiQv rs_aiQw -> f_aiQu (Rec g_aiQv rs_aiQw)
offsetSecs :: forall f_aiQs rs_aiQt. (Functor f_aiQs, RElem OffsetSecs rs_aiQt (RIndex OffsetSecs rs_aiQt)) => (Int -> f_aiQs Int) -> Record rs_aiQt -> f_aiQs (Record rs_aiQt)
type Pitch = (:->) "pitch" Int
pitch' :: forall f_aiSX g_aiSY rs_aiSZ. (Functor f_aiSX, RElem Pitch rs_aiSZ (RIndex Pitch rs_aiSZ)) => (g_aiSY Pitch -> f_aiSX (g_aiSY Pitch)) -> Rec g_aiSY rs_aiSZ -> f_aiSX (Rec g_aiSY rs_aiSZ)
pitch :: forall f_aiSV rs_aiSW. (Functor f_aiSV, RElem Pitch rs_aiSW (RIndex Pitch rs_aiSW)) => (Int -> f_aiSV Int) -> Record rs_aiSW -> f_aiSV (Record rs_aiSW)
type Velocity = (:->) "velocity" Int
velocity' :: forall f_aiVq g_aiVr rs_aiVs. (Functor f_aiVq, RElem Velocity rs_aiVs (RIndex Velocity rs_aiVs)) => (g_aiVr Velocity -> f_aiVq (g_aiVr Velocity)) -> Rec g_aiVr rs_aiVs -> f_aiVq (Rec g_aiVr rs_aiVs)
velocity :: forall f_aiVo rs_aiVp. (Functor f_aiVo, RElem Velocity rs_aiVp (RIndex Velocity rs_aiVp)) => (Int -> f_aiVo Int) -> Record rs_aiVp -> f_aiVo (Record rs_aiVp)
type TrackNum = (:->) "trackNum" Int
trackNum' :: forall f_aiXT g_aiXU rs_aiXV. (Functor f_aiXT, RElem TrackNum rs_aiXV (RIndex TrackNum rs_aiXV)) => (g_aiXU TrackNum -> f_aiXT (g_aiXU TrackNum)) -> Rec g_aiXU rs_aiXV -> f_aiXT (Rec g_aiXU rs_aiXV)
trackNum :: forall f_aiXR rs_aiXS. (Functor f_aiXR, RElem TrackNum rs_aiXS (RIndex TrackNum rs_aiXS)) => (Int -> f_aiXR Int) -> Record rs_aiXS -> f_aiXR (Record rs_aiXS)
type Channel = (:->) "channel" Int
channel' :: forall f_aj0m g_aj0n rs_aj0o. (Functor f_aj0m, RElem Channel rs_aj0o (RIndex Channel rs_aj0o)) => (g_aj0n Channel -> f_aj0m (g_aj0n Channel)) -> Rec g_aj0n rs_aj0o -> f_aj0m (Rec g_aj0n rs_aj0o)
channel :: forall f_aj0k rs_aj0l. (Functor f_aj0k, RElem Channel rs_aj0l (RIndex Channel rs_aj0l)) => (Int -> f_aj0k Int) -> Record rs_aj0l -> f_aj0k (Record rs_aj0l)
type KeySharps = (:->) "keySharps" Int
keySharps' :: forall f_aj2P g_aj2Q rs_aj2R. (Functor f_aj2P, RElem KeySharps rs_aj2R (RIndex KeySharps rs_aj2R)) => (g_aj2Q KeySharps -> f_aj2P (g_aj2Q KeySharps)) -> Rec g_aj2Q rs_aj2R -> f_aj2P (Rec g_aj2Q rs_aj2R)
keySharps :: forall f_aj2N rs_aj2O. (Functor f_aj2N, RElem KeySharps rs_aj2O (RIndex KeySharps rs_aj2O)) => (Int -> f_aj2N Int) -> Record rs_aj2O -> f_aj2N (Record rs_aj2O)
type KeyMajor = (:->) "keyMajor" Bool
keyMajor' :: forall f_aj5i g_aj5j rs_aj5k. (Functor f_aj5i, RElem KeyMajor rs_aj5k (RIndex KeyMajor rs_aj5k)) => (g_aj5j KeyMajor -> f_aj5i (g_aj5j KeyMajor)) -> Rec g_aj5j rs_aj5k -> f_aj5i (Rec g_aj5j rs_aj5k)
keyMajor :: forall f_aj5g rs_aj5h. (Functor f_aj5g, RElem KeyMajor rs_aj5h (RIndex KeyMajor rs_aj5h)) => (Bool -> f_aj5g Bool) -> Record rs_aj5h -> f_aj5g (Record rs_aj5h)
type Bar = (:->) "bar" Int
bar' :: forall f_aj7L g_aj7M rs_aj7N. (Functor f_aj7L, RElem Bar rs_aj7N (RIndex Bar rs_aj7N)) => (g_aj7M Bar -> f_aj7L (g_aj7M Bar)) -> Rec g_aj7M rs_aj7N -> f_aj7L (Rec g_aj7M rs_aj7N)
bar :: forall f_aj7J rs_aj7K. (Functor f_aj7J, RElem Bar rs_aj7K (RIndex Bar rs_aj7K)) => (Int -> f_aj7J Int) -> Record rs_aj7K -> f_aj7J (Record rs_aj7K)
type Beat = (:->) "beat" Int
beat' :: forall f_ajae g_ajaf rs_ajag. (Functor f_ajae, RElem Beat rs_ajag (RIndex Beat rs_ajag)) => (g_ajaf Beat -> f_ajae (g_ajaf Beat)) -> Rec g_ajaf rs_ajag -> f_ajae (Rec g_ajaf rs_ajag)
beat :: forall f_ajac rs_ajad. (Functor f_ajac, RElem Beat rs_ajad (RIndex Beat rs_ajad)) => (Int -> f_ajac Int) -> Record rs_ajad -> f_ajac (Record rs_ajad)
type Subbeat = (:->) "subbeat" RatioInt
subbeat' :: forall f_ajcH g_ajcI rs_ajcJ. (Functor f_ajcH, RElem Subbeat rs_ajcJ (RIndex Subbeat rs_ajcJ)) => (g_ajcI Subbeat -> f_ajcH (g_ajcI Subbeat)) -> Rec g_ajcI rs_ajcJ -> f_ajcH (Rec g_ajcI rs_ajcJ)
subbeat :: forall f_ajcF rs_ajcG. (Functor f_ajcF, RElem Subbeat rs_ajcG (RIndex Subbeat rs_ajcG)) => (RatioInt -> f_ajcF RatioInt) -> Record rs_ajcG -> f_ajcF (Record rs_ajcG)
midiNoteToRecord :: MidiNote -> MidiRecord
printNote :: MidiNote -> IO ()
type PrepEv a = (Int, Message, (a, Message))
prepareTrack :: Track a -> Int -> [PrepEv a]
mergeTracks :: Ord a => [PrepEv a] -> [PrepEv a] -> [PrepEv a]
midiEvents :: Midi -> [PrepEv Ticks]
timeRatios :: TimeDiv -> Int -> (Ratio Int, Double)
type Resolver a = [a] -> [a] -> [a]
queue :: Resolver a
stack :: Resolver a
data OnVal
OnVal :: Int -> Ratio Int -> Double -> Int -> Message -> Int -> Int -> Ratio Int -> OnVal
[ovNowT] :: OnVal -> Int
[ovNowW] :: OnVal -> Ratio Int
[ovNowS] :: OnVal -> Double
[ovVel] :: OnVal -> Int
[ovKeySig] :: OnVal -> Message
[ovBar] :: OnVal -> Int
[ovBeat] :: OnVal -> Int
[ovSubbeat] :: OnVal -> Ratio Int
type Ons = HashMap (Int, Int, Int) [OnVal]
type Coeffs a = (a, a)
data MidiState
MidiState :: Ons -> Coeffs (Ratio Int) -> Coeffs Double -> Ratio Int -> Int -> Ratio Int -> Ratio Int -> MidiState
[msOns] :: MidiState -> Ons
[msWCoeffs] :: MidiState -> Coeffs (Ratio Int)
[msSCoeffs] :: MidiState -> Coeffs Double
[msBarOff] :: MidiState -> Ratio Int
[msBarRef] :: MidiState -> Int
[msBarLen] :: MidiState -> Ratio Int
[msBeatLen] :: MidiState -> Ratio Int
eventsToNotes :: [PrepEv Ticks] -> TimeDiv -> Resolver OnVal -> [MidiNote]
notesToFrame :: [MidiNote] -> Frame MidiRecord
midiTracks :: FilePath -> IO [Track Ticks]
midiLoadEvs :: FilePath -> IO [PrepEv Ticks]
midiLoadNotes :: FilePath -> IO [MidiNote]
pieceBarlen :: FilePath -> IO (Ratio Int)
pieceBeatlen :: Integral a => FilePath -> IO (Ratio a)
dirMidiPieces :: FilePath -> IO [FilePath]
instance GHC.Generics.Generic Musicology.IO.MidiFile.MidiNote
instance GHC.Show.Show Musicology.IO.MidiFile.MidiNote
instance GHC.Classes.Eq Musicology.IO.MidiFile.MidiNote
instance Control.DeepSeq.NFData Musicology.IO.MidiFile.MidiNote

module Musicology.Grams
(.:) :: (b -> c) -> (a -> a -> b) -> a -> a -> c
(.::) :: (b -> c) -> (a -> a -> a -> a -> b) -> a -> a -> a -> a -> c
gramsMach :: Int -> Process a [a]
grams :: Foldable t => Int -> t a -> [[a]]
skipgramsRMach :: (Num k, Ord k, Integral n, Monad m) => m Bool -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> ProcessT m a [a]
skipgramsRSMach :: (Num k, Ord k, Integral n, Monad m) => m Bool -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> ProcessT m a [a]
skipgramsMach :: (Num k, Ord k, Integral n) => ([a] -> Bool) -> (a -> a -> k) -> n -> k -> Process a [a]
skipgramsSMach :: (Num k, Ord k, Integral n) => ([a] -> Bool) -> (a -> a -> k) -> n -> k -> Process a [a]
skipgrams :: (Foldable t, Num k, Ord k, Integral n) => t a -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> [[a]]
skipgramsS :: (Foldable t, Num k, Ord k, Integral n) => t a -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> [[a]]
mkCoin :: (PrimMonad m, Integral n) => Double -> n -> Gen (PrimState m) -> m Bool
skipgramsR :: (Foldable t, Num k, Ord k, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> m [[a]]
skipgramsRS :: (Foldable t, Num k, Ord k, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> m [[a]]
enum :: (Num b, Enum b) => [a] -> [(a, b)]
indexCost :: Num a => (a, a) -> (a, a) -> a
mune :: [[(b, b)]] -> [[b]]
indexSkipgrams :: [a] -> Int -> Int -> [[a]]
indexSkipgramsR :: PrimMonad m => [a] -> Double -> Gen (PrimState m) -> Int -> Int -> m [[a]]
indexSkipgramsS :: [a] -> Int -> Int -> [[a]]
indexSkipgramsRS :: PrimMonad m => [a] -> Double -> Gen (PrimState m) -> Int -> Int -> m [[a]]

module Musicology.Polygrams
onsetdist :: HasTime a => a -> a -> TimeOf a
vonset :: HasTime a => [a] -> TimeOf a
voffset :: (Foldable t, Functor t, HasTime a) => t a -> TimeOf a
nooverlap :: HasTime a => [[a]] -> Bool
groupdist :: HasTime a => TimeOf a -> [a] -> [a] -> TimeOf a
verticals :: (HasTime a, Foldable t, Integral n) => t a -> n -> TimeOf a -> [[a]]
verticalsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> n -> TimeOf a -> m [[a]]
horizontals :: (HasTime a, Foldable t, Integral n) => t [a] -> n -> TimeOf a -> [[[a]]]
horizontalsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t [a] -> Double -> Gen (PrimState m) -> n -> TimeOf a -> m [[[a]]]
polygrams :: (HasTime a, Foldable t, Integral n) => t a -> n -> n -> TimeOf a -> [[[a]]]
polygramsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t a -> Double -> Double -> Gen (PrimState m) -> n -> n -> TimeOf a -> m [[[a]]]
verticalsMach :: (Integral n, Monad m, HasTime a) => m Bool -> n -> TimeOf a -> ProcessT m a [a]
horizontalsMach :: (Integral n, Monad m, HasTime a) => m Bool -> n -> TimeOf a -> ProcessT m [a] [[a]]
polygramsMachR :: (Monad m, HasTime a, Integral n, Integral n) => m Bool -> m Bool -> n -> n -> TimeOf a -> TimeOf a -> MachineT m (Is a) [[a]]
polygramsMach :: (HasTime a, Integral n) => n -> n -> TimeOf a -> TimeOf a -> Process a [[a]]
polygrams' :: (HasTime a, Foldable t, Integral n) => t a -> n -> n -> TimeOf a -> [[[a]]]
