-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/DCMLab/haskell-musicology#readme</a>
@package musicology-extra
@version 0.1.0.0

module Musicology.IO.CSV
fn :: [Char]
type CsvTrack = (:->) "Track" Bool
type CsvChannel = (:->) "Channel" Int
type CsvOnset = (:->) "Onset" Int
type CsvOffset = (:->) "Offset" Int
type CsvPitch = (:->) "Pitch" Int
type CsvVelocity = (:->) "Velocity" Int
type CsvNote = Record '[CsvTrack, CsvChannel, CsvOnset, CsvOffset, CsvPitch, CsvVelocity]
csvVelocity' :: forall f_ad6P g_ad6Q rs_ad6R. (Functor f_ad6P, RElem CsvVelocity rs_ad6R (RIndex CsvVelocity rs_ad6R)) => (g_ad6Q CsvVelocity -> f_ad6P (g_ad6Q CsvVelocity)) -> Rec g_ad6Q rs_ad6R -> f_ad6P (Rec g_ad6Q rs_ad6R)
csvVelocity :: forall f_ad6N rs_ad6O. (Functor f_ad6N, RElem CsvVelocity rs_ad6O (RIndex CsvVelocity rs_ad6O)) => (Int -> f_ad6N Int) -> Record rs_ad6O -> f_ad6N (Record rs_ad6O)
csvPitch' :: forall f_ad6K g_ad6L rs_ad6M. (Functor f_ad6K, RElem CsvPitch rs_ad6M (RIndex CsvPitch rs_ad6M)) => (g_ad6L CsvPitch -> f_ad6K (g_ad6L CsvPitch)) -> Rec g_ad6L rs_ad6M -> f_ad6K (Rec g_ad6L rs_ad6M)
csvPitch :: forall f_ad6I rs_ad6J. (Functor f_ad6I, RElem CsvPitch rs_ad6J (RIndex CsvPitch rs_ad6J)) => (Int -> f_ad6I Int) -> Record rs_ad6J -> f_ad6I (Record rs_ad6J)
csvOffset' :: forall f_ad6F g_ad6G rs_ad6H. (Functor f_ad6F, RElem CsvOffset rs_ad6H (RIndex CsvOffset rs_ad6H)) => (g_ad6G CsvOffset -> f_ad6F (g_ad6G CsvOffset)) -> Rec g_ad6G rs_ad6H -> f_ad6F (Rec g_ad6G rs_ad6H)
csvOffset :: forall f_ad6D rs_ad6E. (Functor f_ad6D, RElem CsvOffset rs_ad6E (RIndex CsvOffset rs_ad6E)) => (Int -> f_ad6D Int) -> Record rs_ad6E -> f_ad6D (Record rs_ad6E)
csvOnset' :: forall f_ad6A g_ad6B rs_ad6C. (Functor f_ad6A, RElem CsvOnset rs_ad6C (RIndex CsvOnset rs_ad6C)) => (g_ad6B CsvOnset -> f_ad6A (g_ad6B CsvOnset)) -> Rec g_ad6B rs_ad6C -> f_ad6A (Rec g_ad6B rs_ad6C)
csvOnset :: forall f_ad6y rs_ad6z. (Functor f_ad6y, RElem CsvOnset rs_ad6z (RIndex CsvOnset rs_ad6z)) => (Int -> f_ad6y Int) -> Record rs_ad6z -> f_ad6y (Record rs_ad6z)
csvChannel' :: forall f_ad6v g_ad6w rs_ad6x. (Functor f_ad6v, RElem CsvChannel rs_ad6x (RIndex CsvChannel rs_ad6x)) => (g_ad6w CsvChannel -> f_ad6v (g_ad6w CsvChannel)) -> Rec g_ad6w rs_ad6x -> f_ad6v (Rec g_ad6w rs_ad6x)
csvChannel :: forall f_ad6t rs_ad6u. (Functor f_ad6t, RElem CsvChannel rs_ad6u (RIndex CsvChannel rs_ad6u)) => (Int -> f_ad6t Int) -> Record rs_ad6u -> f_ad6t (Record rs_ad6u)
csvTrack' :: forall f_ad6q g_ad6r rs_ad6s. (Functor f_ad6q, RElem CsvTrack rs_ad6s (RIndex CsvTrack rs_ad6s)) => (g_ad6r CsvTrack -> f_ad6q (g_ad6r CsvTrack)) -> Rec g_ad6r rs_ad6s -> f_ad6q (Rec g_ad6r rs_ad6s)
csvTrack :: forall f_ad6o rs_ad6p. (Functor f_ad6o, RElem CsvTrack rs_ad6p (RIndex CsvTrack rs_ad6p)) => (Bool -> f_ad6o Bool) -> Record rs_ad6p -> f_ad6o (Record rs_ad6p)
csvNoteParser :: ParserOptions
loadPiece :: FilePath -> IO (Frame CsvNote)
frameNotes :: Frame CsvNote -> [Note MidiInterval Int]

module Musicology.Internal.GatedQueue
type GatedQueue k v = Map k v

-- | <i>O(log n)</i>. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Ord k => k -> a -> Map k a -> Map k a

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
release :: Ord k => GatedQueue k v -> k -> (GatedQueue k v, [v])

-- | <i>O(1)</i>. Is the map empty?
--   
--   <pre>
--   Data.Map.null (empty)           == True
--   Data.Map.null (singleton 1 'a') == False
--   </pre>
null :: Map k a -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression (<tt><a>union</a>
--   t1 t2</tt>) takes the left-biased union of <tt>t1</tt> and
--   <tt>t2</tt>. It prefers <tt>t1</tt> when duplicate keys are
--   encountered, i.e. (<tt><a>union</a> == <a>unionWith</a>
--   <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Ord k => Map k a -> Map k a -> Map k a

module Musicology.Internal.Helpers
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
processFoldable :: Foldable t => t a -> MachineT Identity (Is a) b -> [b]
processFoldableT :: (Monad m, Foldable t) => t a -> ProcessT m a b -> m [b]
showRow :: (RecMapMethod Show ElField a, RecordToList a) => Record a -> String
showHeader :: forall a. ColumnHeaders a => Frame (Record a) -> String
previewFrame :: (RecMapMethod Show ElField a, RecordToList a, ColumnHeaders a) => Int -> Frame (Record a) -> IO ()
viewFrame :: (RecMapMethod Show ElField a, RecordToList a, ColumnHeaders a) => Frame (Record a) -> IO ()
mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
release :: Ord k => Map k v -> k -> (Map k v, [v])
intFills :: (Eq p, Interval p) => p -> p -> Bool
rerunStateT :: (m (a, s) -> n (b, t)) -> (t -> s) -> StateT s m a -> StateT t n b

module Musicology.IO.MidiFile
data MidiNote
MidiNote :: Int -> Int -> Ratio Int -> Ratio Int -> Double -> Double -> MidiPitch -> Int -> Int -> Int -> Int -> Bool -> Int -> Int -> Ratio Int -> MidiNote
[_onsetTicks] :: MidiNote -> Int
[_offsetTicks] :: MidiNote -> Int
[_onsetWholes] :: MidiNote -> Ratio Int
[_offsetWholes] :: MidiNote -> Ratio Int
[_onsetSecs] :: MidiNote -> Double
[_offsetSecs] :: MidiNote -> Double
[_pitch] :: MidiNote -> MidiPitch
[_velocity] :: MidiNote -> Int
[_trackNum] :: MidiNote -> Int
[_channel] :: MidiNote -> Int
[_keySharps] :: MidiNote -> Int
[_keyMajor] :: MidiNote -> Bool
[_bar] :: MidiNote -> Int
[_beat] :: MidiNote -> Int
[_subbeat] :: MidiNote -> Ratio Int
asTicks :: MidiNote -> Note MidiInterval Int
asWholes :: MidiNote -> Note MidiInterval (Ratio Int)
asSecs :: MidiNote -> Note MidiInterval Double
type MidiRecord = Record '["onsetTicks" :-> Int, "offsetTicks" :-> Int, "onsetWholes" :-> Ratio Int, "offsetWholes" :-> Ratio Int, "onsetSecs" :-> Double, "offsetSecs" :-> Double, "pitch" :-> Int, "velocity" :-> Int, "trackNum" :-> Int, "channel" :-> Int, "keySharps" :-> Int, "keyMajor" :-> Bool, "bar" :-> Int, "beat" :-> Int, "subbeat" :-> Ratio Int]
type RatioInt = Ratio Int
type OnsetTicks = (:->) "onsetTicks" Int
onsetTicks' :: forall f_ai6Y g_ai6Z rs_ai70. (Functor f_ai6Y, RElem OnsetTicks rs_ai70 (RIndex OnsetTicks rs_ai70)) => (g_ai6Z OnsetTicks -> f_ai6Y (g_ai6Z OnsetTicks)) -> Rec g_ai6Z rs_ai70 -> f_ai6Y (Rec g_ai6Z rs_ai70)
onsetTicks :: forall f_ai6W rs_ai6X. (Functor f_ai6W, RElem OnsetTicks rs_ai6X (RIndex OnsetTicks rs_ai6X)) => (Int -> f_ai6W Int) -> Record rs_ai6X -> f_ai6W (Record rs_ai6X)
type OffsetTicks = (:->) "offsetTicks" Int
offsetTicks' :: forall f_ai9g g_ai9h rs_ai9i. (Functor f_ai9g, RElem OffsetTicks rs_ai9i (RIndex OffsetTicks rs_ai9i)) => (g_ai9h OffsetTicks -> f_ai9g (g_ai9h OffsetTicks)) -> Rec g_ai9h rs_ai9i -> f_ai9g (Rec g_ai9h rs_ai9i)
offsetTicks :: forall f_ai9e rs_ai9f. (Functor f_ai9e, RElem OffsetTicks rs_ai9f (RIndex OffsetTicks rs_ai9f)) => (Int -> f_ai9e Int) -> Record rs_ai9f -> f_ai9e (Record rs_ai9f)
type OnsetWholes = (:->) "onsetWholes" RatioInt
onsetWholes' :: forall f_aiby g_aibz rs_aibA. (Functor f_aiby, RElem OnsetWholes rs_aibA (RIndex OnsetWholes rs_aibA)) => (g_aibz OnsetWholes -> f_aiby (g_aibz OnsetWholes)) -> Rec g_aibz rs_aibA -> f_aiby (Rec g_aibz rs_aibA)
onsetWholes :: forall f_aibw rs_aibx. (Functor f_aibw, RElem OnsetWholes rs_aibx (RIndex OnsetWholes rs_aibx)) => (RatioInt -> f_aibw RatioInt) -> Record rs_aibx -> f_aibw (Record rs_aibx)
type OffsetWholes = (:->) "offsetWholes" RatioInt
offsetWholes' :: forall f_aidQ g_aidR rs_aidS. (Functor f_aidQ, RElem OffsetWholes rs_aidS (RIndex OffsetWholes rs_aidS)) => (g_aidR OffsetWholes -> f_aidQ (g_aidR OffsetWholes)) -> Rec g_aidR rs_aidS -> f_aidQ (Rec g_aidR rs_aidS)
offsetWholes :: forall f_aidO rs_aidP. (Functor f_aidO, RElem OffsetWholes rs_aidP (RIndex OffsetWholes rs_aidP)) => (RatioInt -> f_aidO RatioInt) -> Record rs_aidP -> f_aidO (Record rs_aidP)
type OnsetSecs = (:->) "onsetSecs" Int
onsetSecs' :: forall f_aig8 g_aig9 rs_aiga. (Functor f_aig8, RElem OnsetSecs rs_aiga (RIndex OnsetSecs rs_aiga)) => (g_aig9 OnsetSecs -> f_aig8 (g_aig9 OnsetSecs)) -> Rec g_aig9 rs_aiga -> f_aig8 (Rec g_aig9 rs_aiga)
onsetSecs :: forall f_aig6 rs_aig7. (Functor f_aig6, RElem OnsetSecs rs_aig7 (RIndex OnsetSecs rs_aig7)) => (Int -> f_aig6 Int) -> Record rs_aig7 -> f_aig6 (Record rs_aig7)
type OffsetSecs = (:->) "offsetSecs" Int
offsetSecs' :: forall f_aiiq g_aiir rs_aiis. (Functor f_aiiq, RElem OffsetSecs rs_aiis (RIndex OffsetSecs rs_aiis)) => (g_aiir OffsetSecs -> f_aiiq (g_aiir OffsetSecs)) -> Rec g_aiir rs_aiis -> f_aiiq (Rec g_aiir rs_aiis)
offsetSecs :: forall f_aiio rs_aiip. (Functor f_aiio, RElem OffsetSecs rs_aiip (RIndex OffsetSecs rs_aiip)) => (Int -> f_aiio Int) -> Record rs_aiip -> f_aiio (Record rs_aiip)
type Pitch = (:->) "pitch" Int
pitch' :: forall f_aikI g_aikJ rs_aikK. (Functor f_aikI, RElem Pitch rs_aikK (RIndex Pitch rs_aikK)) => (g_aikJ Pitch -> f_aikI (g_aikJ Pitch)) -> Rec g_aikJ rs_aikK -> f_aikI (Rec g_aikJ rs_aikK)
pitch :: forall f_aikG rs_aikH. (Functor f_aikG, RElem Pitch rs_aikH (RIndex Pitch rs_aikH)) => (Int -> f_aikG Int) -> Record rs_aikH -> f_aikG (Record rs_aikH)
type Velocity = (:->) "velocity" Int
velocity' :: forall f_ain0 g_ain1 rs_ain2. (Functor f_ain0, RElem Velocity rs_ain2 (RIndex Velocity rs_ain2)) => (g_ain1 Velocity -> f_ain0 (g_ain1 Velocity)) -> Rec g_ain1 rs_ain2 -> f_ain0 (Rec g_ain1 rs_ain2)
velocity :: forall f_aimY rs_aimZ. (Functor f_aimY, RElem Velocity rs_aimZ (RIndex Velocity rs_aimZ)) => (Int -> f_aimY Int) -> Record rs_aimZ -> f_aimY (Record rs_aimZ)
type TrackNum = (:->) "trackNum" Int
trackNum' :: forall f_aipi g_aipj rs_aipk. (Functor f_aipi, RElem TrackNum rs_aipk (RIndex TrackNum rs_aipk)) => (g_aipj TrackNum -> f_aipi (g_aipj TrackNum)) -> Rec g_aipj rs_aipk -> f_aipi (Rec g_aipj rs_aipk)
trackNum :: forall f_aipg rs_aiph. (Functor f_aipg, RElem TrackNum rs_aiph (RIndex TrackNum rs_aiph)) => (Int -> f_aipg Int) -> Record rs_aiph -> f_aipg (Record rs_aiph)
type Channel = (:->) "channel" Int
channel' :: forall f_airA g_airB rs_airC. (Functor f_airA, RElem Channel rs_airC (RIndex Channel rs_airC)) => (g_airB Channel -> f_airA (g_airB Channel)) -> Rec g_airB rs_airC -> f_airA (Rec g_airB rs_airC)
channel :: forall f_airy rs_airz. (Functor f_airy, RElem Channel rs_airz (RIndex Channel rs_airz)) => (Int -> f_airy Int) -> Record rs_airz -> f_airy (Record rs_airz)
type KeySharps = (:->) "keySharps" Int
keySharps' :: forall f_aitS g_aitT rs_aitU. (Functor f_aitS, RElem KeySharps rs_aitU (RIndex KeySharps rs_aitU)) => (g_aitT KeySharps -> f_aitS (g_aitT KeySharps)) -> Rec g_aitT rs_aitU -> f_aitS (Rec g_aitT rs_aitU)
keySharps :: forall f_aitQ rs_aitR. (Functor f_aitQ, RElem KeySharps rs_aitR (RIndex KeySharps rs_aitR)) => (Int -> f_aitQ Int) -> Record rs_aitR -> f_aitQ (Record rs_aitR)
type KeyMajor = (:->) "keyMajor" Bool
keyMajor' :: forall f_aiwa g_aiwb rs_aiwc. (Functor f_aiwa, RElem KeyMajor rs_aiwc (RIndex KeyMajor rs_aiwc)) => (g_aiwb KeyMajor -> f_aiwa (g_aiwb KeyMajor)) -> Rec g_aiwb rs_aiwc -> f_aiwa (Rec g_aiwb rs_aiwc)
keyMajor :: forall f_aiw8 rs_aiw9. (Functor f_aiw8, RElem KeyMajor rs_aiw9 (RIndex KeyMajor rs_aiw9)) => (Bool -> f_aiw8 Bool) -> Record rs_aiw9 -> f_aiw8 (Record rs_aiw9)
type Bar = (:->) "bar" Int
bar' :: forall f_aiys g_aiyt rs_aiyu. (Functor f_aiys, RElem Bar rs_aiyu (RIndex Bar rs_aiyu)) => (g_aiyt Bar -> f_aiys (g_aiyt Bar)) -> Rec g_aiyt rs_aiyu -> f_aiys (Rec g_aiyt rs_aiyu)
bar :: forall f_aiyq rs_aiyr. (Functor f_aiyq, RElem Bar rs_aiyr (RIndex Bar rs_aiyr)) => (Int -> f_aiyq Int) -> Record rs_aiyr -> f_aiyq (Record rs_aiyr)
type Beat = (:->) "beat" Int
beat' :: forall f_aiAK g_aiAL rs_aiAM. (Functor f_aiAK, RElem Beat rs_aiAM (RIndex Beat rs_aiAM)) => (g_aiAL Beat -> f_aiAK (g_aiAL Beat)) -> Rec g_aiAL rs_aiAM -> f_aiAK (Rec g_aiAL rs_aiAM)
beat :: forall f_aiAI rs_aiAJ. (Functor f_aiAI, RElem Beat rs_aiAJ (RIndex Beat rs_aiAJ)) => (Int -> f_aiAI Int) -> Record rs_aiAJ -> f_aiAI (Record rs_aiAJ)
type Subbeat = (:->) "subbeat" RatioInt
subbeat' :: forall f_aiD2 g_aiD3 rs_aiD4. (Functor f_aiD2, RElem Subbeat rs_aiD4 (RIndex Subbeat rs_aiD4)) => (g_aiD3 Subbeat -> f_aiD2 (g_aiD3 Subbeat)) -> Rec g_aiD3 rs_aiD4 -> f_aiD2 (Rec g_aiD3 rs_aiD4)
subbeat :: forall f_aiD0 rs_aiD1. (Functor f_aiD0, RElem Subbeat rs_aiD1 (RIndex Subbeat rs_aiD1)) => (RatioInt -> f_aiD0 RatioInt) -> Record rs_aiD1 -> f_aiD0 (Record rs_aiD1)
midiNoteToRecord :: MidiNote -> MidiRecord
printNote :: MidiNote -> IO ()
type PrepEv a = (Int, Message, (a, Message))
prepareTrack :: Track a -> Int -> [PrepEv a]
mergeTracks :: Ord a => [PrepEv a] -> [PrepEv a] -> [PrepEv a]
midiEvents :: Midi -> [PrepEv Ticks]
timeRatios :: TimeDiv -> Int -> (Ratio Int, Double)
type Resolver a = [a] -> [a] -> [a]
queue :: Resolver a
stack :: Resolver a
data OnVal
OnVal :: Int -> Ratio Int -> Double -> Int -> Message -> Int -> Int -> Ratio Int -> OnVal
[ovNowT] :: OnVal -> Int
[ovNowW] :: OnVal -> Ratio Int
[ovNowS] :: OnVal -> Double
[ovVel] :: OnVal -> Int
[ovKeySig] :: OnVal -> Message
[ovBar] :: OnVal -> Int
[ovBeat] :: OnVal -> Int
[ovSubbeat] :: OnVal -> Ratio Int
type Ons = HashMap (Int, Int, Int) [OnVal]
type Coeffs a = (a, a)
data MidiState
MidiState :: Ons -> Coeffs (Ratio Int) -> Coeffs Double -> Ratio Int -> Int -> Ratio Int -> Ratio Int -> MidiState
[msOns] :: MidiState -> Ons
[msWCoeffs] :: MidiState -> Coeffs (Ratio Int)
[msSCoeffs] :: MidiState -> Coeffs Double
[msBarOff] :: MidiState -> Ratio Int
[msBarRef] :: MidiState -> Int
[msBarLen] :: MidiState -> Ratio Int
[msBeatLen] :: MidiState -> Ratio Int
eventsToNotes :: [PrepEv Ticks] -> TimeDiv -> Resolver OnVal -> [MidiNote]
notesToFrame :: [MidiNote] -> Frame MidiRecord
midiTracks :: FilePath -> IO [Track Ticks]
midiLoadEvs :: FilePath -> IO [PrepEv Ticks]
midiLoadNotes :: FilePath -> IO [MidiNote]
pieceBarlen :: FilePath -> IO (Ratio Int)
pieceBeatlen :: Integral a => FilePath -> IO (Ratio a)
dirMidiPieces :: FilePath -> IO [FilePath]
instance GHC.Generics.Generic Musicology.IO.MidiFile.MidiNote
instance GHC.Show.Show Musicology.IO.MidiFile.MidiNote
instance GHC.Classes.Eq Musicology.IO.MidiFile.MidiNote
instance Control.DeepSeq.NFData Musicology.IO.MidiFile.MidiNote

module Musicology.Grams
(.:) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
(.::) :: (b -> c) -> (a1 -> a2 -> a3 -> a4 -> b) -> a1 -> a2 -> a3 -> a4 -> c
gramsMach :: Int -> Process a [a]
grams :: Foldable t => Int -> t a -> [[a]]
skipgramsRMach :: (Num k, Ord k, Integral n, Monad m) => m Bool -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> ProcessT m a [a]
skipgramsRSMach :: (Num k, Ord k, Integral n, Monad m) => m Bool -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> ProcessT m a [a]
skipgramsMach :: (Num k, Ord k, Integral n) => ([a] -> Bool) -> (a -> a -> k) -> n -> k -> Process a [a]
skipgramsSMach :: (Num k, Ord k, Integral n) => ([a] -> Bool) -> (a -> a -> k) -> n -> k -> Process a [a]
skipgrams :: (Foldable t, Num k, Ord k, Integral n) => t a -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> [[a]]
skipgramsS :: (Foldable t, Num k, Ord k, Integral n) => t a -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> [[a]]
mkCoin :: (PrimMonad m, Integral n) => Double -> n -> Gen (PrimState m) -> m Bool
skipgramsR :: (Foldable t, Num k, Ord k, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> m [[a]]
skipgramsRS :: (Foldable t, Num k, Ord k, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> m [[a]]
enum :: (Num b, Enum b) => [a] -> [(a, b)]
indexCost :: Num a1 => (a2, a1) -> (a3, a1) -> a1
mune :: [[(b1, b2)]] -> [[b1]]
indexSkipgrams :: [a] -> Int -> Int -> [[a]]
indexSkipgramsR :: PrimMonad m => [a] -> Double -> Gen (PrimState m) -> Int -> Int -> m [[a]]
indexSkipgramsS :: [a] -> Int -> Int -> [[a]]
indexSkipgramsRS :: PrimMonad m => [a] -> Double -> Gen (PrimState m) -> Int -> Int -> m [[a]]

module Musicology.Polygrams
onsetdist :: HasTime a => a -> a -> TimeOf a
vonset :: HasTime a => [a] -> TimeOf a
voffset :: (Foldable t, Functor t, HasTime a) => t a -> TimeOf a
nooverlap :: HasTime a => [[a]] -> Bool
groupdist :: HasTime a => TimeOf a -> [a] -> [a] -> TimeOf a
verticals :: (HasTime a, Foldable t, Integral n) => t a -> n -> TimeOf a -> [[a]]
verticalsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> n -> TimeOf a -> m [[a]]
horizontals :: (HasTime a, Foldable t, Integral n) => t [a] -> n -> TimeOf a -> [[[a]]]
horizontalsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t [a] -> Double -> Gen (PrimState m) -> n -> TimeOf a -> m [[[a]]]
polygrams :: (HasTime a, Foldable t, Integral n) => t a -> n -> n -> TimeOf a -> [[[a]]]
polygramsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t a -> Double -> Double -> Gen (PrimState m) -> n -> n -> TimeOf a -> m [[[a]]]
verticalsMach :: (Integral n, Monad m, HasTime a) => m Bool -> n -> TimeOf a -> ProcessT m a [a]
horizontalsMach :: (Integral n, Monad m, HasTime a) => m Bool -> n -> TimeOf a -> ProcessT m [a] [[a]]
polygramsMachR :: (Monad m, HasTime a, Integral n1, Integral n2) => m Bool -> m Bool -> n1 -> n2 -> TimeOf a -> TimeOf a -> MachineT m (Is a) [[a]]
polygramsMach :: (HasTime a, Integral n) => n -> n -> TimeOf a -> TimeOf a -> Process a [[a]]
polygrams' :: (HasTime a, Foldable t, Integral n) => t a -> n -> n -> TimeOf a -> [[[a]]]
