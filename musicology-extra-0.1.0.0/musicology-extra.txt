-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/DCMLab/haskell-musicology#readme</a>
@package musicology-extra
@version 0.1.0.0

module Musicology.IO.CSV
fn :: [Char]
type CsvTrack = (:->) "Track" Bool
type CsvChannel = (:->) "Channel" Int
type CsvOnset = (:->) "Onset" Int
type CsvOffset = (:->) "Offset" Int
type CsvPitch = (:->) "Pitch" Int
type CsvVelocity = (:->) "Velocity" Int
type CsvNote = Record '[CsvTrack, CsvChannel, CsvOnset, CsvOffset, CsvPitch, CsvVelocity]
csvVelocity' :: forall f_adt1 g_adt2 rs_adt3. (Functor f_adt1, RElem CsvVelocity rs_adt3 (RIndex CsvVelocity rs_adt3)) => (g_adt2 CsvVelocity -> f_adt1 (g_adt2 CsvVelocity)) -> Rec g_adt2 rs_adt3 -> f_adt1 (Rec g_adt2 rs_adt3)
csvVelocity :: forall f_adsZ rs_adt0. (Functor f_adsZ, RElem CsvVelocity rs_adt0 (RIndex CsvVelocity rs_adt0)) => (Int -> f_adsZ Int) -> Record rs_adt0 -> f_adsZ (Record rs_adt0)
csvPitch' :: forall f_adsW g_adsX rs_adsY. (Functor f_adsW, RElem CsvPitch rs_adsY (RIndex CsvPitch rs_adsY)) => (g_adsX CsvPitch -> f_adsW (g_adsX CsvPitch)) -> Rec g_adsX rs_adsY -> f_adsW (Rec g_adsX rs_adsY)
csvPitch :: forall f_adsU rs_adsV. (Functor f_adsU, RElem CsvPitch rs_adsV (RIndex CsvPitch rs_adsV)) => (Int -> f_adsU Int) -> Record rs_adsV -> f_adsU (Record rs_adsV)
csvOffset' :: forall f_adsR g_adsS rs_adsT. (Functor f_adsR, RElem CsvOffset rs_adsT (RIndex CsvOffset rs_adsT)) => (g_adsS CsvOffset -> f_adsR (g_adsS CsvOffset)) -> Rec g_adsS rs_adsT -> f_adsR (Rec g_adsS rs_adsT)
csvOffset :: forall f_adsP rs_adsQ. (Functor f_adsP, RElem CsvOffset rs_adsQ (RIndex CsvOffset rs_adsQ)) => (Int -> f_adsP Int) -> Record rs_adsQ -> f_adsP (Record rs_adsQ)
csvOnset' :: forall f_adsM g_adsN rs_adsO. (Functor f_adsM, RElem CsvOnset rs_adsO (RIndex CsvOnset rs_adsO)) => (g_adsN CsvOnset -> f_adsM (g_adsN CsvOnset)) -> Rec g_adsN rs_adsO -> f_adsM (Rec g_adsN rs_adsO)
csvOnset :: forall f_adsK rs_adsL. (Functor f_adsK, RElem CsvOnset rs_adsL (RIndex CsvOnset rs_adsL)) => (Int -> f_adsK Int) -> Record rs_adsL -> f_adsK (Record rs_adsL)
csvChannel' :: forall f_adsH g_adsI rs_adsJ. (Functor f_adsH, RElem CsvChannel rs_adsJ (RIndex CsvChannel rs_adsJ)) => (g_adsI CsvChannel -> f_adsH (g_adsI CsvChannel)) -> Rec g_adsI rs_adsJ -> f_adsH (Rec g_adsI rs_adsJ)
csvChannel :: forall f_adsF rs_adsG. (Functor f_adsF, RElem CsvChannel rs_adsG (RIndex CsvChannel rs_adsG)) => (Int -> f_adsF Int) -> Record rs_adsG -> f_adsF (Record rs_adsG)
csvTrack' :: forall f_adsC g_adsD rs_adsE. (Functor f_adsC, RElem CsvTrack rs_adsE (RIndex CsvTrack rs_adsE)) => (g_adsD CsvTrack -> f_adsC (g_adsD CsvTrack)) -> Rec g_adsD rs_adsE -> f_adsC (Rec g_adsD rs_adsE)
csvTrack :: forall f_adsA rs_adsB. (Functor f_adsA, RElem CsvTrack rs_adsB (RIndex CsvTrack rs_adsB)) => (Bool -> f_adsA Bool) -> Record rs_adsB -> f_adsA (Record rs_adsB)
csvNoteParser :: ParserOptions
loadPiece :: FilePath -> IO (Frame CsvNote)
frameNotes :: Frame CsvNote -> [Note MidiInterval Int]

module Musicology.Internal.GatedQueue
type GatedQueue k v = Map k v

-- | <i>O(log n)</i>. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Ord k => k -> a -> Map k a -> Map k a

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
release :: Ord k => GatedQueue k v -> k -> (GatedQueue k v, [v])

-- | <i>O(1)</i>. Is the map empty?
--   
--   <pre>
--   Data.Map.null (empty)           == True
--   Data.Map.null (singleton 1 'a') == False
--   </pre>
null :: Map k a -> Bool

-- | <i>O(m*log(n/m + 1)), m &lt;= n</i>. The expression (<tt><a>union</a>
--   t1 t2</tt>) takes the left-biased union of <tt>t1</tt> and
--   <tt>t2</tt>. It prefers <tt>t1</tt> when duplicate keys are
--   encountered, i.e. (<tt><a>union</a> == <a>unionWith</a>
--   <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Ord k => Map k a -> Map k a -> Map k a

module Musicology.Internal.Helpers
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
processFoldable :: Foldable t => t a -> MachineT Identity (Is a) b -> [b]
processFoldableT :: (Monad m, Foldable t) => t a -> ProcessT m a b -> m [b]
showRow :: (RecMapMethod Show ElField a, RecordToList a) => Record a -> String
showHeader :: forall a. ColumnHeaders a => Frame (Record a) -> String
previewFrame :: (RecMapMethod Show ElField a, RecordToList a, ColumnHeaders a) => Int -> Frame (Record a) -> IO ()
viewFrame :: (RecMapMethod Show ElField a, RecordToList a, ColumnHeaders a) => Frame (Record a) -> IO ()
mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
release :: Ord k => Map k v -> k -> (Map k v, [v])
intFills :: (Eq p, Interval p) => p -> p -> Bool
rerunStateT :: (m (a, s) -> n (b, t)) -> (t -> s) -> StateT s m a -> StateT t n b

module Musicology.IO.MidiFile
data MidiNote
MidiNote :: Int -> Int -> Ratio Int -> Ratio Int -> Double -> Double -> MidiPitch -> Int -> Int -> Int -> Int -> Bool -> Int -> Int -> Ratio Int -> MidiNote
[_onsetTicks] :: MidiNote -> Int
[_offsetTicks] :: MidiNote -> Int
[_onsetWholes] :: MidiNote -> Ratio Int
[_offsetWholes] :: MidiNote -> Ratio Int
[_onsetSecs] :: MidiNote -> Double
[_offsetSecs] :: MidiNote -> Double
[_pitch] :: MidiNote -> MidiPitch
[_velocity] :: MidiNote -> Int
[_trackNum] :: MidiNote -> Int
[_channel] :: MidiNote -> Int
[_keySharps] :: MidiNote -> Int
[_keyMajor] :: MidiNote -> Bool
[_bar] :: MidiNote -> Int
[_beat] :: MidiNote -> Int
[_subbeat] :: MidiNote -> Ratio Int
asTicks :: MidiNote -> Note MidiInterval Int
asWholes :: MidiNote -> Note MidiInterval (Ratio Int)
asSecs :: MidiNote -> Note MidiInterval Double
type MidiRecord = Record '["onsetTicks" :-> Int, "offsetTicks" :-> Int, "onsetWholes" :-> Ratio Int, "offsetWholes" :-> Ratio Int, "onsetSecs" :-> Double, "offsetSecs" :-> Double, "pitch" :-> Int, "velocity" :-> Int, "trackNum" :-> Int, "channel" :-> Int, "keySharps" :-> Int, "keyMajor" :-> Bool, "bar" :-> Int, "beat" :-> Int, "subbeat" :-> Ratio Int]
type RatioInt = Ratio Int
type OnsetTicks = (:->) "onsetTicks" Int
onsetTicks' :: forall f_aisW g_aisX rs_aisY. (Functor f_aisW, RElem OnsetTicks rs_aisY (RIndex OnsetTicks rs_aisY)) => (g_aisX OnsetTicks -> f_aisW (g_aisX OnsetTicks)) -> Rec g_aisX rs_aisY -> f_aisW (Rec g_aisX rs_aisY)
onsetTicks :: forall f_aisU rs_aisV. (Functor f_aisU, RElem OnsetTicks rs_aisV (RIndex OnsetTicks rs_aisV)) => (Int -> f_aisU Int) -> Record rs_aisV -> f_aisU (Record rs_aisV)
type OffsetTicks = (:->) "offsetTicks" Int
offsetTicks' :: forall f_aive g_aivf rs_aivg. (Functor f_aive, RElem OffsetTicks rs_aivg (RIndex OffsetTicks rs_aivg)) => (g_aivf OffsetTicks -> f_aive (g_aivf OffsetTicks)) -> Rec g_aivf rs_aivg -> f_aive (Rec g_aivf rs_aivg)
offsetTicks :: forall f_aivc rs_aivd. (Functor f_aivc, RElem OffsetTicks rs_aivd (RIndex OffsetTicks rs_aivd)) => (Int -> f_aivc Int) -> Record rs_aivd -> f_aivc (Record rs_aivd)
type OnsetWholes = (:->) "onsetWholes" RatioInt
onsetWholes' :: forall f_aixw g_aixx rs_aixy. (Functor f_aixw, RElem OnsetWholes rs_aixy (RIndex OnsetWholes rs_aixy)) => (g_aixx OnsetWholes -> f_aixw (g_aixx OnsetWholes)) -> Rec g_aixx rs_aixy -> f_aixw (Rec g_aixx rs_aixy)
onsetWholes :: forall f_aixu rs_aixv. (Functor f_aixu, RElem OnsetWholes rs_aixv (RIndex OnsetWholes rs_aixv)) => (RatioInt -> f_aixu RatioInt) -> Record rs_aixv -> f_aixu (Record rs_aixv)
type OffsetWholes = (:->) "offsetWholes" RatioInt
offsetWholes' :: forall f_aizO g_aizP rs_aizQ. (Functor f_aizO, RElem OffsetWholes rs_aizQ (RIndex OffsetWholes rs_aizQ)) => (g_aizP OffsetWholes -> f_aizO (g_aizP OffsetWholes)) -> Rec g_aizP rs_aizQ -> f_aizO (Rec g_aizP rs_aizQ)
offsetWholes :: forall f_aizM rs_aizN. (Functor f_aizM, RElem OffsetWholes rs_aizN (RIndex OffsetWholes rs_aizN)) => (RatioInt -> f_aizM RatioInt) -> Record rs_aizN -> f_aizM (Record rs_aizN)
type OnsetSecs = (:->) "onsetSecs" Int
onsetSecs' :: forall f_aiC6 g_aiC7 rs_aiC8. (Functor f_aiC6, RElem OnsetSecs rs_aiC8 (RIndex OnsetSecs rs_aiC8)) => (g_aiC7 OnsetSecs -> f_aiC6 (g_aiC7 OnsetSecs)) -> Rec g_aiC7 rs_aiC8 -> f_aiC6 (Rec g_aiC7 rs_aiC8)
onsetSecs :: forall f_aiC4 rs_aiC5. (Functor f_aiC4, RElem OnsetSecs rs_aiC5 (RIndex OnsetSecs rs_aiC5)) => (Int -> f_aiC4 Int) -> Record rs_aiC5 -> f_aiC4 (Record rs_aiC5)
type OffsetSecs = (:->) "offsetSecs" Int
offsetSecs' :: forall f_aiEo g_aiEp rs_aiEq. (Functor f_aiEo, RElem OffsetSecs rs_aiEq (RIndex OffsetSecs rs_aiEq)) => (g_aiEp OffsetSecs -> f_aiEo (g_aiEp OffsetSecs)) -> Rec g_aiEp rs_aiEq -> f_aiEo (Rec g_aiEp rs_aiEq)
offsetSecs :: forall f_aiEm rs_aiEn. (Functor f_aiEm, RElem OffsetSecs rs_aiEn (RIndex OffsetSecs rs_aiEn)) => (Int -> f_aiEm Int) -> Record rs_aiEn -> f_aiEm (Record rs_aiEn)
type Pitch = (:->) "pitch" Int
pitch' :: forall f_aiGG g_aiGH rs_aiGI. (Functor f_aiGG, RElem Pitch rs_aiGI (RIndex Pitch rs_aiGI)) => (g_aiGH Pitch -> f_aiGG (g_aiGH Pitch)) -> Rec g_aiGH rs_aiGI -> f_aiGG (Rec g_aiGH rs_aiGI)
pitch :: forall f_aiGE rs_aiGF. (Functor f_aiGE, RElem Pitch rs_aiGF (RIndex Pitch rs_aiGF)) => (Int -> f_aiGE Int) -> Record rs_aiGF -> f_aiGE (Record rs_aiGF)
type Velocity = (:->) "velocity" Int
velocity' :: forall f_aiIY g_aiIZ rs_aiJ0. (Functor f_aiIY, RElem Velocity rs_aiJ0 (RIndex Velocity rs_aiJ0)) => (g_aiIZ Velocity -> f_aiIY (g_aiIZ Velocity)) -> Rec g_aiIZ rs_aiJ0 -> f_aiIY (Rec g_aiIZ rs_aiJ0)
velocity :: forall f_aiIW rs_aiIX. (Functor f_aiIW, RElem Velocity rs_aiIX (RIndex Velocity rs_aiIX)) => (Int -> f_aiIW Int) -> Record rs_aiIX -> f_aiIW (Record rs_aiIX)
type TrackNum = (:->) "trackNum" Int
trackNum' :: forall f_aiLg g_aiLh rs_aiLi. (Functor f_aiLg, RElem TrackNum rs_aiLi (RIndex TrackNum rs_aiLi)) => (g_aiLh TrackNum -> f_aiLg (g_aiLh TrackNum)) -> Rec g_aiLh rs_aiLi -> f_aiLg (Rec g_aiLh rs_aiLi)
trackNum :: forall f_aiLe rs_aiLf. (Functor f_aiLe, RElem TrackNum rs_aiLf (RIndex TrackNum rs_aiLf)) => (Int -> f_aiLe Int) -> Record rs_aiLf -> f_aiLe (Record rs_aiLf)
type Channel = (:->) "channel" Int
channel' :: forall f_aiNy g_aiNz rs_aiNA. (Functor f_aiNy, RElem Channel rs_aiNA (RIndex Channel rs_aiNA)) => (g_aiNz Channel -> f_aiNy (g_aiNz Channel)) -> Rec g_aiNz rs_aiNA -> f_aiNy (Rec g_aiNz rs_aiNA)
channel :: forall f_aiNw rs_aiNx. (Functor f_aiNw, RElem Channel rs_aiNx (RIndex Channel rs_aiNx)) => (Int -> f_aiNw Int) -> Record rs_aiNx -> f_aiNw (Record rs_aiNx)
type KeySharps = (:->) "keySharps" Int
keySharps' :: forall f_aiPQ g_aiPR rs_aiPS. (Functor f_aiPQ, RElem KeySharps rs_aiPS (RIndex KeySharps rs_aiPS)) => (g_aiPR KeySharps -> f_aiPQ (g_aiPR KeySharps)) -> Rec g_aiPR rs_aiPS -> f_aiPQ (Rec g_aiPR rs_aiPS)
keySharps :: forall f_aiPO rs_aiPP. (Functor f_aiPO, RElem KeySharps rs_aiPP (RIndex KeySharps rs_aiPP)) => (Int -> f_aiPO Int) -> Record rs_aiPP -> f_aiPO (Record rs_aiPP)
type KeyMajor = (:->) "keyMajor" Bool
keyMajor' :: forall f_aiS8 g_aiS9 rs_aiSa. (Functor f_aiS8, RElem KeyMajor rs_aiSa (RIndex KeyMajor rs_aiSa)) => (g_aiS9 KeyMajor -> f_aiS8 (g_aiS9 KeyMajor)) -> Rec g_aiS9 rs_aiSa -> f_aiS8 (Rec g_aiS9 rs_aiSa)
keyMajor :: forall f_aiS6 rs_aiS7. (Functor f_aiS6, RElem KeyMajor rs_aiS7 (RIndex KeyMajor rs_aiS7)) => (Bool -> f_aiS6 Bool) -> Record rs_aiS7 -> f_aiS6 (Record rs_aiS7)
type Bar = (:->) "bar" Int
bar' :: forall f_aiUq g_aiUr rs_aiUs. (Functor f_aiUq, RElem Bar rs_aiUs (RIndex Bar rs_aiUs)) => (g_aiUr Bar -> f_aiUq (g_aiUr Bar)) -> Rec g_aiUr rs_aiUs -> f_aiUq (Rec g_aiUr rs_aiUs)
bar :: forall f_aiUo rs_aiUp. (Functor f_aiUo, RElem Bar rs_aiUp (RIndex Bar rs_aiUp)) => (Int -> f_aiUo Int) -> Record rs_aiUp -> f_aiUo (Record rs_aiUp)
type Beat = (:->) "beat" Int
beat' :: forall f_aiWI g_aiWJ rs_aiWK. (Functor f_aiWI, RElem Beat rs_aiWK (RIndex Beat rs_aiWK)) => (g_aiWJ Beat -> f_aiWI (g_aiWJ Beat)) -> Rec g_aiWJ rs_aiWK -> f_aiWI (Rec g_aiWJ rs_aiWK)
beat :: forall f_aiWG rs_aiWH. (Functor f_aiWG, RElem Beat rs_aiWH (RIndex Beat rs_aiWH)) => (Int -> f_aiWG Int) -> Record rs_aiWH -> f_aiWG (Record rs_aiWH)
type Subbeat = (:->) "subbeat" RatioInt
subbeat' :: forall f_aiZ0 g_aiZ1 rs_aiZ2. (Functor f_aiZ0, RElem Subbeat rs_aiZ2 (RIndex Subbeat rs_aiZ2)) => (g_aiZ1 Subbeat -> f_aiZ0 (g_aiZ1 Subbeat)) -> Rec g_aiZ1 rs_aiZ2 -> f_aiZ0 (Rec g_aiZ1 rs_aiZ2)
subbeat :: forall f_aiYY rs_aiYZ. (Functor f_aiYY, RElem Subbeat rs_aiYZ (RIndex Subbeat rs_aiYZ)) => (RatioInt -> f_aiYY RatioInt) -> Record rs_aiYZ -> f_aiYY (Record rs_aiYZ)
midiNoteToRecord :: MidiNote -> MidiRecord
printNote :: MidiNote -> IO ()
type PrepEv a = (Int, Message, (a, Message))
prepareTrack :: Track a -> Int -> [PrepEv a]
mergeTracks :: Ord a => [PrepEv a] -> [PrepEv a] -> [PrepEv a]
midiEvents :: Midi -> [PrepEv Ticks]
timeRatios :: TimeDiv -> Int -> (Ratio Int, Double)
type Resolver a = [a] -> [a] -> [a]
queue :: Resolver a
stack :: Resolver a
data OnVal
OnVal :: Int -> Ratio Int -> Double -> Int -> Message -> Int -> Int -> Ratio Int -> OnVal
[ovNowT] :: OnVal -> Int
[ovNowW] :: OnVal -> Ratio Int
[ovNowS] :: OnVal -> Double
[ovVel] :: OnVal -> Int
[ovKeySig] :: OnVal -> Message
[ovBar] :: OnVal -> Int
[ovBeat] :: OnVal -> Int
[ovSubbeat] :: OnVal -> Ratio Int
type Ons = HashMap (Int, Int, Int) [OnVal]
type Coeffs a = (a, a)
data MidiState
MidiState :: Ons -> Coeffs (Ratio Int) -> Coeffs Double -> Ratio Int -> Int -> Ratio Int -> Ratio Int -> MidiState
[msOns] :: MidiState -> Ons
[msWCoeffs] :: MidiState -> Coeffs (Ratio Int)
[msSCoeffs] :: MidiState -> Coeffs Double
[msBarOff] :: MidiState -> Ratio Int
[msBarRef] :: MidiState -> Int
[msBarLen] :: MidiState -> Ratio Int
[msBeatLen] :: MidiState -> Ratio Int
eventsToNotes :: [PrepEv Ticks] -> TimeDiv -> Resolver OnVal -> [MidiNote]
notesToFrame :: [MidiNote] -> Frame MidiRecord
midiTracks :: FilePath -> IO [Track Ticks]
midiLoadEvs :: FilePath -> IO [PrepEv Ticks]
midiLoadNotes :: FilePath -> IO [MidiNote]
pieceBarlen :: FilePath -> IO (Ratio Int)
pieceBeatlen :: Integral a => FilePath -> IO (Ratio a)
dirMidiPieces :: FilePath -> IO [FilePath]
instance GHC.Generics.Generic Musicology.IO.MidiFile.MidiNote
instance GHC.Show.Show Musicology.IO.MidiFile.MidiNote
instance GHC.Classes.Eq Musicology.IO.MidiFile.MidiNote
instance Control.DeepSeq.NFData Musicology.IO.MidiFile.MidiNote

module Musicology.Grams
(.:) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
(.::) :: (b -> c) -> (a1 -> a2 -> a3 -> a4 -> b) -> a1 -> a2 -> a3 -> a4 -> c
gramsMach :: Int -> Process a [a]
grams :: Foldable t => Int -> t a -> [[a]]
skipgramsRMach :: (Num k, Ord k, Integral n, Monad m) => m Bool -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> ProcessT m a [a]
skipgramsRSMach :: (Num k, Ord k, Integral n, Monad m) => m Bool -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> ProcessT m a [a]
skipgramsMach :: (Num k, Ord k, Integral n) => ([a] -> Bool) -> (a -> a -> k) -> n -> k -> Process a [a]
skipgramsSMach :: (Num k, Ord k, Integral n) => ([a] -> Bool) -> (a -> a -> k) -> n -> k -> Process a [a]
skipgrams :: (Foldable t, Num k, Ord k, Integral n) => t a -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> [[a]]
skipgramsS :: (Foldable t, Num k, Ord k, Integral n) => t a -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> [[a]]
mkCoin :: (PrimMonad m, Integral n) => Double -> n -> Gen (PrimState m) -> m Bool
skipgramsR :: (Foldable t, Num k, Ord k, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> m [[a]]
skipgramsRS :: (Foldable t, Num k, Ord k, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> ([a] -> Bool) -> (a -> a -> k) -> n -> k -> m [[a]]
enum :: (Num b, Enum b) => [a] -> [(a, b)]
indexCost :: Num a1 => (a2, a1) -> (a3, a1) -> a1
mune :: [[(b1, b2)]] -> [[b1]]
indexSkipgrams :: [a] -> Int -> Int -> [[a]]
indexSkipgramsR :: PrimMonad m => [a] -> Double -> Gen (PrimState m) -> Int -> Int -> m [[a]]
indexSkipgramsS :: [a] -> Int -> Int -> [[a]]
indexSkipgramsRS :: PrimMonad m => [a] -> Double -> Gen (PrimState m) -> Int -> Int -> m [[a]]

module Musicology.Polygrams
onsetdist :: HasTime a => a -> a -> TimeOf a
vonset :: HasTime a => [a] -> TimeOf a
voffset :: (Foldable t, Functor t, HasTime a) => t a -> TimeOf a
nooverlap :: HasTime a => [[a]] -> Bool
groupdist :: HasTime a => TimeOf a -> [a] -> [a] -> TimeOf a
verticals :: (HasTime a, Foldable t, Integral n) => t a -> n -> TimeOf a -> [[a]]
verticalsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t a -> Double -> Gen (PrimState m) -> n -> TimeOf a -> m [[a]]
horizontals :: (HasTime a, Foldable t, Integral n) => t [a] -> n -> TimeOf a -> [[[a]]]
horizontalsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t [a] -> Double -> Gen (PrimState m) -> n -> TimeOf a -> m [[[a]]]
polygrams :: (HasTime a, Foldable t, Integral n) => t a -> n -> n -> TimeOf a -> [[[a]]]
polygramsR :: (HasTime a, Foldable t, Integral n, PrimMonad m) => t a -> Double -> Double -> Gen (PrimState m) -> n -> n -> TimeOf a -> m [[[a]]]
verticalsMach :: (Integral n, Monad m, HasTime a) => m Bool -> n -> TimeOf a -> ProcessT m a [a]
horizontalsMach :: (Integral n, Monad m, HasTime a) => m Bool -> n -> TimeOf a -> ProcessT m [a] [[a]]
polygramsMachR :: (Monad m, HasTime a, Integral n1, Integral n2) => m Bool -> m Bool -> n1 -> n2 -> TimeOf a -> TimeOf a -> MachineT m (Is a) [[a]]
polygramsMach :: (HasTime a, Integral n) => n -> n -> TimeOf a -> TimeOf a -> Process a [[a]]
polygrams' :: (HasTime a, Foldable t, Integral n) => t a -> n -> n -> TimeOf a -> [[[a]]]
